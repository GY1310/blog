<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>数据结构与算法 | clay's blog</title><meta name="description" content="数据结构(java语言描述)"><meta name="keywords" content="Java,笔记"><meta name="author" content="clay"><meta name="copyright" content="clay"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/icon.png"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="数据结构与算法"><meta name="twitter:description" content="数据结构(java语言描述)"><meta name="twitter:image" content="https://pic.downk.cc/item/5e67934098271cb2b8c73daf.jpg"><meta property="og:type" content="article"><meta property="og:title" content="数据结构与算法"><meta property="og:url" content="http://yoursite.com/2020/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><meta property="og:site_name" content="clay's blog"><meta property="og:description" content="数据结构(java语言描述)"><meta property="og:image" content="https://pic.downk.cc/item/5e67934098271cb2b8c73daf.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'true'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.15/dist/snackbar.min.css"><link rel="canonical" href="http://yoursite.com/2020/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><link rel="prev" title="置顶文章测试" href="http://yoursite.com/2020/03/10/test2/"><link rel="next" title="java语法-04" href="http://yoursite.com/2020/03/09/java%E8%AF%AD%E6%B3%95-04/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: undefined,
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: {"languages":{"author":"作者: clay","link":"链接: http://yoursite.com/2020/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","source":"来源: clay's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  copy_copyright_js: true,
  ClickShowText: undefined,
  medium_zoom: 'false',
  Snackbar: {"bookmark":{"title":"Snackbar.bookmark.title","message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"}
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">clay's blog</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/blog/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/blog/tags"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/blog/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/blog/link/"><i class="fa-fw fa fa-link"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/blog/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/blog/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/blog/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="https://pic.downk.cc/item/5e6601de98271cb2b81548a3.jpg" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">14</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">7</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/blog/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/blog/tags"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/blog/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/blog/link/"><i class="fa-fw fa fa-link"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/blog/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/blog/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/blog/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#数据结构与算法"><span class="toc_mobile_items-text">数据结构与算法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-稀疏数组的代码实现"><span class="toc_mobile_items-text">1.稀疏数组的代码实现</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-使用数组模拟队列"><span class="toc_mobile_items-text">2.使用数组模拟队列</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-使用数组模拟环形队列"><span class="toc_mobile_items-text">3.使用数组模拟环形队列</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-单向链表的创建和遍历"><span class="toc_mobile_items-text">4.单向链表的创建和遍历</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-单向链表按顺序插入节点"><span class="toc_mobile_items-text">5.单向链表按顺序插入节点</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-单向链表节点的修改"><span class="toc_mobile_items-text">6.单向链表节点的修改</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-单向链表节点的删除"><span class="toc_mobile_items-text">7.单向链表节点的删除</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#8-单向链表有效节点的个数"><span class="toc_mobile_items-text">8.单向链表有效节点的个数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#9-查找单向链表中的倒数第K个节点【新浪】"><span class="toc_mobile_items-text">9.查找单向链表中的倒数第K个节点【新浪】</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#10-单向链表的翻转【腾讯】"><span class="toc_mobile_items-text">10.单向链表的翻转【腾讯】</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#11-从尾到头打印单向链表【百度】"><span class="toc_mobile_items-text">11.从尾到头打印单向链表【百度】</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#12-双向链表的遍历增、删、改、查"><span class="toc_mobile_items-text">12.双向链表的遍历增、删、改、查</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#13-约瑟夫问题-环形链表"><span class="toc_mobile_items-text">13.约瑟夫问题(环形链表)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#14-数组模拟栈"><span class="toc_mobile_items-text">14.数组模拟栈</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#15-使用栈完成计算表达式的结果"><span class="toc_mobile_items-text">15.使用栈完成计算表达式的结果</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-逆波兰计算器"><span class="toc_mobile_items-text">16.逆波兰计算器</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#17-中缀表达式转后缀表达式"><span class="toc_mobile_items-text">17.中缀表达式转后缀表达式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#18-递归的调用机制-打印-amp-阶乘"><span class="toc_mobile_items-text">18.递归的调用机制(打印&amp;阶乘)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#19-递归-迷宫问题"><span class="toc_mobile_items-text">19.递归-迷宫问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#20-八皇后问题"><span class="toc_mobile_items-text">20.八皇后问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#21-冒泡排序"><span class="toc_mobile_items-text">21.冒泡排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#22-选择排序"><span class="toc_mobile_items-text">22.选择排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#23-插入排序"><span class="toc_mobile_items-text">23.插入排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#24-希尔排序-交换法"><span class="toc_mobile_items-text">24.希尔排序(交换法)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#25-希尔排序-移位法"><span class="toc_mobile_items-text">25.希尔排序(移位法)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#26-快速排序"><span class="toc_mobile_items-text">26.快速排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#27-归并排序"><span class="toc_mobile_items-text">27.归并排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#28-基数排序"><span class="toc_mobile_items-text">28.基数排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#29-线性查找"><span class="toc_mobile_items-text">29.线性查找</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#30-二分查找"><span class="toc_mobile_items-text">30.二分查找</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#31-差值查找"><span class="toc_mobile_items-text">31.差值查找</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#32-斐波那契查找"><span class="toc_mobile_items-text">32.斐波那契查找</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#33-哈希表"><span class="toc_mobile_items-text">33.哈希表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#34-二叉树"><span class="toc_mobile_items-text">34.二叉树</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#35-顺序存储二叉树"><span class="toc_mobile_items-text">35.顺序存储二叉树</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#36-线索化二叉树"><span class="toc_mobile_items-text">36.线索化二叉树</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#37-堆排序"><span class="toc_mobile_items-text">37.堆排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#38-赫夫曼树"><span class="toc_mobile_items-text">38.赫夫曼树</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#39-图"><span class="toc_mobile_items-text">39.图</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#40-图的深度优先遍历-DFS"><span class="toc_mobile_items-text">40.图的深度优先遍历 DFS</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#程序员常用的十种算法"><span class="toc_mobile_items-text">程序员常用的十种算法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#41-二分查找-非递归"><span class="toc_mobile_items-text">41.二分查找(非递归)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#42-分治算法-汉诺塔"><span class="toc_mobile_items-text">42.分治算法(汉诺塔)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#43-动态规划"><span class="toc_mobile_items-text">43.动态规划</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#44-暴力匹配"><span class="toc_mobile_items-text">44.暴力匹配</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#45-kmp算法"><span class="toc_mobile_items-text">45.kmp算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#46-贪心算法"><span class="toc_mobile_items-text">46.贪心算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#未完待续……"><span class="toc_mobile_items-text">未完待续……</span></a></li></ol></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#数据结构与算法"><span class="toc-text">数据结构与算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-稀疏数组的代码实现"><span class="toc-text">1.稀疏数组的代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-使用数组模拟队列"><span class="toc-text">2.使用数组模拟队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-使用数组模拟环形队列"><span class="toc-text">3.使用数组模拟环形队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-单向链表的创建和遍历"><span class="toc-text">4.单向链表的创建和遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-单向链表按顺序插入节点"><span class="toc-text">5.单向链表按顺序插入节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-单向链表节点的修改"><span class="toc-text">6.单向链表节点的修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-单向链表节点的删除"><span class="toc-text">7.单向链表节点的删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-单向链表有效节点的个数"><span class="toc-text">8.单向链表有效节点的个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-查找单向链表中的倒数第K个节点【新浪】"><span class="toc-text">9.查找单向链表中的倒数第K个节点【新浪】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-单向链表的翻转【腾讯】"><span class="toc-text">10.单向链表的翻转【腾讯】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-从尾到头打印单向链表【百度】"><span class="toc-text">11.从尾到头打印单向链表【百度】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-双向链表的遍历增、删、改、查"><span class="toc-text">12.双向链表的遍历增、删、改、查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-约瑟夫问题-环形链表"><span class="toc-text">13.约瑟夫问题(环形链表)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-数组模拟栈"><span class="toc-text">14.数组模拟栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-使用栈完成计算表达式的结果"><span class="toc-text">15.使用栈完成计算表达式的结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-逆波兰计算器"><span class="toc-text">16.逆波兰计算器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-中缀表达式转后缀表达式"><span class="toc-text">17.中缀表达式转后缀表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-递归的调用机制-打印-amp-阶乘"><span class="toc-text">18.递归的调用机制(打印&amp;阶乘)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-递归-迷宫问题"><span class="toc-text">19.递归-迷宫问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-八皇后问题"><span class="toc-text">20.八皇后问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-冒泡排序"><span class="toc-text">21.冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-选择排序"><span class="toc-text">22.选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-插入排序"><span class="toc-text">23.插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-希尔排序-交换法"><span class="toc-text">24.希尔排序(交换法)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-希尔排序-移位法"><span class="toc-text">25.希尔排序(移位法)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-快速排序"><span class="toc-text">26.快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-归并排序"><span class="toc-text">27.归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-基数排序"><span class="toc-text">28.基数排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-线性查找"><span class="toc-text">29.线性查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-二分查找"><span class="toc-text">30.二分查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-差值查找"><span class="toc-text">31.差值查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-斐波那契查找"><span class="toc-text">32.斐波那契查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-哈希表"><span class="toc-text">33.哈希表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-二叉树"><span class="toc-text">34.二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-顺序存储二叉树"><span class="toc-text">35.顺序存储二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-线索化二叉树"><span class="toc-text">36.线索化二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-堆排序"><span class="toc-text">37.堆排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38-赫夫曼树"><span class="toc-text">38.赫夫曼树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-图"><span class="toc-text">39.图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-图的深度优先遍历-DFS"><span class="toc-text">40.图的深度优先遍历 DFS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#程序员常用的十种算法"><span class="toc-text">程序员常用的十种算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#41-二分查找-非递归"><span class="toc-text">41.二分查找(非递归)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-分治算法-汉诺塔"><span class="toc-text">42.分治算法(汉诺塔)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-动态规划"><span class="toc-text">43.动态规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-暴力匹配"><span class="toc-text">44.暴力匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-kmp算法"><span class="toc-text">45.kmp算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-贪心算法"><span class="toc-text">46.贪心算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#未完待续……"><span class="toc-text">未完待续……</span></a></li></ol></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://pic.downk.cc/item/5e67934098271cb2b8c73daf.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">数据结构与算法</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-03-10<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-03-13</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon" aria-hidden="true"></i><span>字数总计: </span><span class="word-count">41.3k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon" aria-hidden="true"></i><span>阅读时长: 172 分钟</span><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true">       </i><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h3 id="1-稀疏数组的代码实现"><a href="#1-稀疏数组的代码实现" class="headerlink" title="1.稀疏数组的代码实现"></a>1.稀疏数组的代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseArray</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 稀疏数组是用来简化数组存放数据的形式</span></span><br><span class="line"><span class="comment">		 * 稀疏数组永远是三列的</span></span><br><span class="line"><span class="comment">		 * 稀疏数组的第一行第一列用来存放原始数组的行数，第二列用来存放原始数组的列数，第三列用来存放非0元素的个数</span></span><br><span class="line"><span class="comment">		 * 稀疏数组的从第二行开始就是第一列存放非0元素的行的位置，第二列用来存放非0元素列的位置，第三列用来存放非0元素的值</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * */</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 创建一个原始的二维数组11*11</span></span><br><span class="line">		<span class="comment">// 0表示没有棋子，1表示黑子，2表示白子</span></span><br><span class="line">		<span class="keyword">int</span> chessArr1[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">		chessArr1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">		chessArr1[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">		chessArr1[<span class="number">4</span>][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">		chessArr1[<span class="number">7</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="comment">// 输出原始的二维数组</span></span><br><span class="line">		System.out.println(<span class="string">"原始的二维数组~"</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr1) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123;</span><br><span class="line">				System.out.printf(<span class="string">"%d\t"</span>, data);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将二维数组转稀疏数组的思想</span></span><br><span class="line">		<span class="comment">// 1.先遍历二维数组 得到非0数据个数</span></span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (chessArr1[j][i] != <span class="number">0</span>) &#123;</span><br><span class="line">					sum++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		System.out.println(sum);</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2.创建对应的稀疏数组</span></span><br><span class="line">		<span class="keyword">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">		<span class="comment">// 给稀疏数组赋值</span></span><br><span class="line">		sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">		sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">		sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 遍历二维数组，将非0的值存放到稀疏数组sparseArr里面去</span></span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">// count用于记录第几个非0数据</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">					count++;</span><br><span class="line">					sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">					sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">					sparseArr[count][<span class="number">2</span>] = chessArr1[i][j];</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//输出稀疏数组的形式</span></span><br><span class="line">		System.out.println();</span><br><span class="line">		System.out.println(<span class="string">"得到的稀疏数组为以下形式"</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;sparseArr.length;i++)&#123;</span><br><span class="line">			System.out.printf(<span class="string">"%d\t%d\t%d\t\n"</span>,sparseArr[i][<span class="number">0</span>],sparseArr[i][<span class="number">1</span>],sparseArr[i][<span class="number">2</span>]); </span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将稀疏数组恢复成原始的二维数组</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 1.先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的chessArr2 = [11][11]</span></span><br><span class="line"><span class="comment">		 * 2.在读取稀疏数组后几行数据，并赋值给原始的二维数组即可</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * */</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//1.先读取稀疏数组的地上传，根据第一行的数据，创建原始的二维数组</span></span><br><span class="line">		<span class="keyword">int</span> chessArr2[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2.在读取稀疏数组后几行数据，并赋值给原始的二维数组即可</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;sparseArr.length;i++)&#123;</span><br><span class="line">			chessArr2[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]]=sparseArr[i][<span class="number">2</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//输出恢复后的二维数组</span></span><br><span class="line">		System.out.println();</span><br><span class="line">		System.out.println(<span class="string">"恢复后的二维数组"</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> row[]:chessArr2)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> data:row)&#123;</span><br><span class="line">				System.out.printf(<span class="string">"%d\t"</span>,data);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-使用数组模拟队列"><a href="#2-使用数组模拟队列" class="headerlink" title="2.使用数组模拟队列"></a>2.使用数组模拟队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueueDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arsgs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 测试一把</span></span><br><span class="line">		<span class="comment">// 创建一个队列</span></span><br><span class="line">		ArrayQueue queue = <span class="keyword">new</span> ArrayQueue(<span class="number">3</span>);</span><br><span class="line">		<span class="keyword">char</span> key = <span class="string">' '</span>;<span class="comment">// 接收用户输入</span></span><br><span class="line">		Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line">		<span class="comment">// 输出一个菜单</span></span><br><span class="line">		<span class="keyword">while</span> (loop) &#123;</span><br><span class="line">			System.out.println(<span class="string">"s(show):显示队列"</span>);</span><br><span class="line">			System.out.println(<span class="string">"e(exit):退出程序"</span>);</span><br><span class="line">			System.out.println(<span class="string">"a(add):添加数据到队列"</span>);</span><br><span class="line">			System.out.println(<span class="string">"g(get):从队列取出数据"</span>);</span><br><span class="line">			System.out.println(<span class="string">"h(head):查看队列头的数据"</span>);</span><br><span class="line">			key = scanner.next().charAt(<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">switch</span> (key) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'s'</span>:<span class="comment">// 查看数据</span></span><br><span class="line">				queue.showQueue();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'a'</span>:<span class="comment">// 添加数据</span></span><br><span class="line">				System.out.println(<span class="string">"请输入一个数字"</span>);</span><br><span class="line">				<span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">				queue.addQueue(value);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'g'</span>:<span class="comment">// 取出数据</span></span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">int</span> res = queue.getQueue();</span><br><span class="line">					System.out.printf(<span class="string">"取出的数据是%d\n"</span>, res);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">					System.out.println(e.getMessage());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'h'</span>:<span class="comment">// 查看队列头数据</span></span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">int</span> res = queue.headQueue();</span><br><span class="line">					System.out.printf(<span class="string">"队列头的数据是%d\n"</span>, res);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">					System.out.println(e.getMessage());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'e'</span>:<span class="comment">// 退出</span></span><br><span class="line">				scanner.close();</span><br><span class="line">				loop = <span class="keyword">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"程序退出"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用数组模拟队列-编写一个ArrayQueue类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">// 表示数组的最大容量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> front;<span class="comment">// 队列头</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> rear;<span class="comment">// 队列尾</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] arr;<span class="comment">// 该数据用于存放数据，模拟队列</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建队列的构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> arrMaxSize)</span> </span>&#123;</span><br><span class="line">		maxSize = arrMaxSize;</span><br><span class="line">		arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">		front = -<span class="number">1</span>;<span class="comment">// 指向队列头，分析出front是指向队列头的前一个位置</span></span><br><span class="line">		rear = -<span class="number">1</span>;<span class="comment">// 指向队列尾，指向队列尾的数据(就是队列最后一个数据)</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断队列是否满</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> rear == maxSize - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断队列是否为空</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> rear == front;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加数据到队列</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断队列是否满</span></span><br><span class="line">		<span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"队列满，不能够加入数据"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		rear++;<span class="comment">// 让 rear后移</span></span><br><span class="line">	</span><br><span class="line">		arr[rear] = n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取队列的数据</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断队列是否空</span></span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">			<span class="comment">// 通过抛出异常处理</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列为空,不能取数据"</span>);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		front++;<span class="comment">// front后移</span></span><br><span class="line">	</span><br><span class="line">		<span class="keyword">return</span> arr[front];</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示队列的所有数据</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 遍历</span></span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"队列为空，没有数据"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			System.out.printf(<span class="string">"arr[%d]=%d\n"</span>, i, arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示队列的头数据，注意不是取出数据</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断</span></span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列为空，没有数据"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> arr[front + <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-使用数组模拟环形队列"><a href="#3-使用数组模拟环形队列" class="headerlink" title="3.使用数组模拟环形队列"></a>3.使用数组模拟环形队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 思路如下：</span></span><br><span class="line"><span class="comment"> *  1.front变量的含义作一个调整，front就指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素		front的初始值为=0</span></span><br><span class="line"><span class="comment"> *  2.rear变量的含义作一个调整，rear指向队列的最后一个元素的后一个位置，因为希望空出一个空间作为约定			rear的初始值为=0</span></span><br><span class="line"><span class="comment"> * 	3.当队列满时，条件是(rear+1)%maxSize=front 【满】</span></span><br><span class="line"><span class="comment"> *  4.当队列为空时，条件是rear==font 【空】</span></span><br><span class="line"><span class="comment"> * 	5.当我们这样分析，队列中有效的数据个数(rear+maxSize-front)%maxSize    //	rear=1 	font=0</span></span><br><span class="line"><span class="comment"> * 	6.我们就可以在原来的队列上进行修改，得到一个环形队列</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleArrayQueueDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 测试一把</span></span><br><span class="line">		<span class="comment">// 创建一个队列</span></span><br><span class="line">		CircleArray queue = <span class="keyword">new</span> CircleArray(<span class="number">4</span>);<span class="comment">// 说明:设置4其队列有效数据最大为3个</span></span><br><span class="line">		<span class="keyword">char</span> key = <span class="string">' '</span>;<span class="comment">// 接收用户输入</span></span><br><span class="line">		Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line">		<span class="comment">// 输出一个菜单</span></span><br><span class="line">		<span class="keyword">while</span> (loop) &#123;</span><br><span class="line">			System.out.println(<span class="string">"s(show):显示队列"</span>);</span><br><span class="line">			System.out.println(<span class="string">"e(exit):退出程序"</span>);</span><br><span class="line">			System.out.println(<span class="string">"a(add):添加数据到队列"</span>);</span><br><span class="line">			System.out.println(<span class="string">"g(get):从队列取出数据"</span>);</span><br><span class="line">			System.out.println(<span class="string">"h(head):查看队列头的数据"</span>);</span><br><span class="line">			key = scanner.next().charAt(<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">switch</span> (key) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'s'</span>:<span class="comment">// 查看数据</span></span><br><span class="line">				queue.showQueue();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'a'</span>:<span class="comment">// 添加数据</span></span><br><span class="line">				System.out.println(<span class="string">"请输入一个数字"</span>);</span><br><span class="line">				<span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">				queue.addQueue(value);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'g'</span>:<span class="comment">// 取出数据</span></span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">int</span> res = queue.getQueue();</span><br><span class="line">					System.out.printf(<span class="string">"取出的数据是%d\n"</span>, res);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">					System.out.println(e.getMessage());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'h'</span>:<span class="comment">// 查看队列头数据</span></span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">int</span> res = queue.headQueue();</span><br><span class="line">					System.out.printf(<span class="string">"队列头的数据是%d\n"</span>, res);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">					System.out.println(e.getMessage());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'e'</span>:<span class="comment">// 退出</span></span><br><span class="line">				scanner.close();</span><br><span class="line">				loop = <span class="keyword">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"程序退出"</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleArray</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">// 表示数组的最大容量</span></span><br><span class="line">	<span class="comment">// front就指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素</span></span><br><span class="line">	<span class="comment">// front的初始值为=0</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">	<span class="comment">// rear指向队列的最后一个元素的后一个位置，因为希望空出一个空间作为约定</span></span><br><span class="line">	<span class="comment">// rear的初始值为=0</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] arr;<span class="comment">// 该数据用于存放数据，模拟队列</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CircleArray</span><span class="params">(<span class="keyword">int</span> arrMaxSize)</span> </span>&#123;</span><br><span class="line">		maxSize = arrMaxSize;</span><br><span class="line">		arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">		front = <span class="number">0</span>;</span><br><span class="line">		rear = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断队列是否满</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (rear + <span class="number">1</span>) % maxSize == front;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断是否为空</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> rear == front;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加数据到队列</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断队列是否满</span></span><br><span class="line">		<span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"队列满，不能够加入数据"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 直接将数据加入</span></span><br><span class="line">		arr[rear] = n;</span><br><span class="line">		<span class="comment">// 将rear后移，这里必须考虑取模</span></span><br><span class="line">		rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取队列的数据，出队列</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断队列是否空</span></span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">			<span class="comment">// 通过抛出异常处理</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列为空,不能取数据"</span>);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 这里需要分析出font是指向队列的第一个元素</span></span><br><span class="line">		<span class="comment">// 1.先把front对应的值保存到一个临时变量</span></span><br><span class="line">		<span class="comment">// 2.将front后移</span></span><br><span class="line">		<span class="comment">// 3.将临时保存的变量返回</span></span><br><span class="line">		<span class="keyword">int</span> value = arr[front];</span><br><span class="line">		front = (front + <span class="number">1</span>) % maxSize;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示队列的所有数据</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 遍历</span></span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"队列为空，没有数据"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 思路从front开始遍历，遍历多少个元素</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = front; i &lt; front + size(); i++) &#123;</span><br><span class="line">			System.out.printf(<span class="string">"arr[%d]=%d\n"</span>, i % maxSize, arr[i % maxSize]);</span><br><span class="line">			<span class="comment">// 为什么(i%maxSize)，因为不一定是i，还可能超过这个数组的大小，所以要取模</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 求出当前队列有效数据个数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * rear=1 front=0 maxSize=3</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">return</span> (rear + maxSize - front) % maxSize;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示队列的头数据，注意不是取出数据</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断</span></span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列为空，没有数据"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> arr[front];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-单向链表的创建和遍历"><a href="#4-单向链表的创建和遍历" class="headerlink" title="4.单向链表的创建和遍历"></a>4.单向链表的创建和遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	添加(创建)</span></span><br><span class="line"><span class="comment">	1.先创建一个head头节点，作用就是表示单链表的头</span></span><br><span class="line"><span class="comment">	2.后面我们每添加一个节点，就直接加入到链表的最后</span></span><br><span class="line"><span class="comment">	遍历:</span></span><br><span class="line"><span class="comment">	1.通过一个辅助遍历，帮助遍历整个链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedListDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 进行测试</span></span><br><span class="line">		<span class="comment">// 先创建节点</span></span><br><span class="line">		HeroNode h1 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">"宋江"</span>, <span class="string">"及时雨"</span>);</span><br><span class="line">		HeroNode h2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">"卢俊义"</span>, <span class="string">"玉麒麟"</span>);</span><br><span class="line">		HeroNode h3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">"吴用"</span>, <span class="string">"智多星"</span>);</span><br><span class="line">		HeroNode h4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">"林冲"</span>, <span class="string">"豹子头"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建一个链表</span></span><br><span class="line">		SingleLinkedList singleLinkedList = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line">		<span class="comment">// 加入</span></span><br><span class="line">		</span><br><span class="line">		singleLinkedList.add(h1);</span><br><span class="line">		singleLinkedList.add(h2);</span><br><span class="line">		singleLinkedList.add(h3);</span><br><span class="line">		singleLinkedList.add(h4);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 显示</span></span><br><span class="line">		singleLinkedList.list();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义SingleLinkedList管理我们的英雄</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 先初始化一个头节点，头节点不要动，不存放具体的数据</span></span><br><span class="line">	<span class="keyword">private</span> HeroNode head = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 添加节点到单向链表 思路，不考虑编号顺序时 1.找到当前链表的最后节点 2.将这个节点的next指向新的节点</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 因为head节点不能动，因此我们需要一个辅助变量temp</span></span><br><span class="line">		HeroNode temp = head;</span><br><span class="line">		<span class="comment">// 遍历链表，找到最后</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">// 找到链表的最后</span></span><br><span class="line">			<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果没有找到最后，就将temp后移</span></span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 当退出while循环的时候，temp就指向了链表的最后</span></span><br><span class="line">		temp.next = heroNode;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示链表 通过遍历来完成</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断链表是否为空</span></span><br><span class="line">		<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">		HeroNode temp = head.next;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">// 判断是否为空</span></span><br><span class="line">			<span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 输出节点的信息</span></span><br><span class="line">			System.out.println(temp);</span><br><span class="line">			<span class="comment">// 将temp后移，一定要小心</span></span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义HeroNode，每一个HeroNode的对象就是一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="keyword">public</span> String nickname;</span><br><span class="line">	<span class="keyword">public</span> HeroNode next;<span class="comment">// 指向下一个节点</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.no = no;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">", nickname="</span>+ nickname + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为了显示方法，我们重写toString方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-单向链表按顺序插入节点"><a href="#5-单向链表按顺序插入节点" class="headerlink" title="5.单向链表按顺序插入节点"></a>5.单向链表按顺序插入节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	需要按照编号顺序的添加</span></span><br><span class="line"><span class="comment">	1.首先找到新添加的节点的位置，是通过辅助变量(指针),通过遍历来搞定</span></span><br><span class="line"><span class="comment">	2.新的节点.next=temp.next</span></span><br><span class="line"><span class="comment">    3.将temp.next=新的节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedListDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 进行测试</span></span><br><span class="line">		<span class="comment">// 先创建节点</span></span><br><span class="line">		HeroNode h1 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">"宋江"</span>, <span class="string">"及时雨"</span>);</span><br><span class="line">		HeroNode h2 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">"卢俊义"</span>, <span class="string">"玉麒麟"</span>);</span><br><span class="line">		HeroNode h3 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">"吴用"</span>, <span class="string">"智多星"</span>);</span><br><span class="line">		HeroNode h4 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">"林冲"</span>, <span class="string">"豹子头"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建一个链表</span></span><br><span class="line">		SingleLinkedList singleLinkedList = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 加入</span></span><br><span class="line">		singleLinkedList.addByOrder(h1);</span><br><span class="line">		singleLinkedList.addByOrder(h2);</span><br><span class="line">		singleLinkedList.addByOrder(h3);</span><br><span class="line">		singleLinkedList.addByOrder(h4);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 显示</span></span><br><span class="line">		singleLinkedList.list();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义SingleLinkedList管理我们的英雄</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 先初始化一个头节点，头节点不要动，不存放具体的数据</span></span><br><span class="line">	<span class="keyword">private</span> HeroNode head = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 添加节点到单向链表 思路，不考虑编号顺序时 1.找到当前链表的最后节点 2.将这个节点的next指向新的节点</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 因为head节点不能动，因此我们需要一个辅助变量temp</span></span><br><span class="line">		HeroNode temp = head;</span><br><span class="line">		<span class="comment">// 遍历链表，找到最后</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">// 找到链表的最后</span></span><br><span class="line">			<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果没有找到最后，就将temp后移</span></span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 当退出while循环的时候，temp就指向了链表的最后</span></span><br><span class="line">		temp.next = heroNode;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第二种方式在添加英雄时，根据排名将英雄插入到指定的位置</span></span><br><span class="line">	<span class="comment">// 将最后这个节点的next 指向新的节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助我们找到添加的位置</span></span><br><span class="line">		<span class="comment">// 因为单链表，因此我们找的temp是位于添加位置的前一个节点，否则插入不了</span></span><br><span class="line">		HeroNode temp = head;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">// flag标志添加的编号是否存在，默认为false</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;<span class="comment">// 说明temp已经在链表的最后</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;<span class="comment">// 位置找到了，就在temp的后面插入</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;<span class="comment">// 说明希望添加的heroNode的编号已经存在</span></span><br><span class="line">				flag = <span class="keyword">true</span>; <span class="comment">// 说明编号存在</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.next;<span class="comment">// 后移，遍历链表</span></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 判断flag的值</span></span><br><span class="line">		<span class="keyword">if</span> (flag) &#123;<span class="comment">// 不能添加，说明编号存在</span></span><br><span class="line">			System.out.printf(<span class="string">"准备插入的英雄%d已经存在了，不能加入\n"</span>, heroNode.no);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 插入到链表中，temp后面</span></span><br><span class="line">			heroNode.next = temp.next;</span><br><span class="line">			temp.next = heroNode;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示链表 通过遍历来完成</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断链表是否为空</span></span><br><span class="line">		<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">		HeroNode temp = head.next;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">// 判断是否为空</span></span><br><span class="line">			<span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 输出节点的信息</span></span><br><span class="line">			System.out.println(temp);</span><br><span class="line">			<span class="comment">// 将temp后移，一定要小心</span></span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义HeroNode，每一个HeroNode的对象就是一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="keyword">public</span> String nickname;</span><br><span class="line">	<span class="keyword">public</span> HeroNode next;<span class="comment">// 指向下一个节点</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.no = no;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了显示方法，我们重写toString方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">", nickname="</span></span><br><span class="line">				+ nickname + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-单向链表节点的修改"><a href="#6-单向链表节点的修改" class="headerlink" title="6.单向链表节点的修改"></a>6.单向链表节点的修改</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	需要按照编号顺序的添加</span></span><br><span class="line"><span class="comment">	1.首先找到新添加的节点的位置，是通过辅助变量(指针),通过遍历来搞定</span></span><br><span class="line"><span class="comment">	2.新的节点.next=temp.next</span></span><br><span class="line"><span class="comment">    3.将temp.next=新的节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedListDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 进行测试</span></span><br><span class="line">		<span class="comment">// 先创建节点</span></span><br><span class="line">		HeroNode h1 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">"宋江"</span>, <span class="string">"及时雨"</span>);</span><br><span class="line">		HeroNode h2 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">"卢俊义"</span>, <span class="string">"玉麒麟"</span>);</span><br><span class="line">		HeroNode h3 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">"吴用"</span>, <span class="string">"智多星"</span>);</span><br><span class="line">		HeroNode h4 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">"林冲"</span>, <span class="string">"豹子头"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建一个链表</span></span><br><span class="line">		SingleLinkedList singleLinkedList = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 加入</span></span><br><span class="line">		singleLinkedList.addByOrder(h1);</span><br><span class="line">		singleLinkedList.addByOrder(h2);</span><br><span class="line">		singleLinkedList.addByOrder(h3);</span><br><span class="line">		singleLinkedList.addByOrder(h4);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 显示</span></span><br><span class="line">		singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 修改</span></span><br><span class="line">		HeroNode h5 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">"小卢"</span>, <span class="string">"玉麒麟~"</span>);</span><br><span class="line">		singleLinkedList.update(h5);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 显示修改过后的结果</span></span><br><span class="line">		singleLinkedList.list();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义SingleLinkedList管理我们的英雄</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 先初始化一个头节点，头节点不要动，不存放具体的数据</span></span><br><span class="line">	<span class="keyword">private</span> HeroNode head = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 添加节点到单向链表 思路，不考虑编号顺序时 1.找到当前链表的最后节点 2.将这个节点的next指向新的节点</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 因为head节点不能动，因此我们需要一个辅助变量temp</span></span><br><span class="line">		HeroNode temp = head;</span><br><span class="line">		<span class="comment">// 遍历链表，找到最后</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">// 找到链表的最后</span></span><br><span class="line">			<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果没有找到最后，就将temp后移</span></span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 当退出while循环的时候，temp就指向了链表的最后</span></span><br><span class="line">		temp.next = heroNode;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第二种方式在添加英雄时，根据排名将英雄插入到指定的位置</span></span><br><span class="line">	<span class="comment">// 将最后这个节点的next 指向新的节点</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助我们找到添加的位置</span></span><br><span class="line">		<span class="comment">// 因为单链表，因此我们找的temp是位于添加位置的前一个节点，否则插入不了</span></span><br><span class="line">		HeroNode temp = head;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">// flag标志添加的编号是否存在，默认为false</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;<span class="comment">// 说明temp已经在链表的最后</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;<span class="comment">// 位置找到了，就在temp的后面插入</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;<span class="comment">// 说明希望添加的heroNode的编号已经存在</span></span><br><span class="line">				flag = <span class="keyword">true</span>; <span class="comment">// 说明编号存在</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.next;<span class="comment">// 后移，遍历链表</span></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 判断flag的值</span></span><br><span class="line">		<span class="keyword">if</span> (flag) &#123;<span class="comment">// 不能添加，说明编号存在</span></span><br><span class="line">			System.out.printf(<span class="string">"准备插入的英雄%d已经存在了，不能加入\n"</span>, heroNode.no);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 插入到链表中，temp后面</span></span><br><span class="line">			heroNode.next = temp.next;</span><br><span class="line">			temp.next = heroNode;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 修改节点的信息，根据no编号来修改，即no编号不能改</span></span><br><span class="line">	<span class="comment">// 说明:</span></span><br><span class="line">	<span class="comment">// 1.根据newHeroNode的no来修改</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode newHeroNode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断是否为空</span></span><br><span class="line">		<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 找到需要修改的节点，根据no编号</span></span><br><span class="line">		<span class="comment">// 定义一个辅助变量</span></span><br><span class="line">		HeroNode temp = head.next;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">// 表示是否找到该节点</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">// 已经遍历完链表了</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;</span><br><span class="line">				<span class="comment">// 找到了</span></span><br><span class="line">				flag = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.next;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 根据flag判断是否找到</span></span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="keyword">true</span>) &#123;</span><br><span class="line">			temp.name = newHeroNode.name;</span><br><span class="line">			temp.nickname = newHeroNode.nickname;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;<span class="comment">// 没有找到</span></span><br><span class="line">			System.out.printf(<span class="string">"没有找到编号%d的节点，不能修改\n"</span>, newHeroNode.no);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示链表 通过遍历来完成</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断链表是否为空</span></span><br><span class="line">		<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">		HeroNode temp = head.next;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">// 判断是否为空</span></span><br><span class="line">			<span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 输出节点的信息</span></span><br><span class="line">			System.out.println(temp);</span><br><span class="line">			<span class="comment">// 将temp后移，一定要小心</span></span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义HeroNode，每一个HeroNode的对象就是一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="keyword">public</span> String nickname;</span><br><span class="line">	<span class="keyword">public</span> HeroNode next;<span class="comment">// 指向下一个节点</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.no = no;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为了显示方法，我们重写toString方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">", nickname="</span></span><br><span class="line">				+ nickname + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-单向链表节点的删除"><a href="#7-单向链表节点的删除" class="headerlink" title="7.单向链表节点的删除"></a>7.单向链表节点的删除</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	从单向链表中删除一个节点的思路</span></span><br><span class="line"><span class="comment">	1.我们先找到需要删除的这个节点的前一个节点temp</span></span><br><span class="line"><span class="comment">	2.temp.next=temp.next.next;</span></span><br><span class="line"><span class="comment">	3.被删除的节点，将不会有其它引用指向，会被垃圾回收机制所回收</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedListDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 进行测试</span></span><br><span class="line">		<span class="comment">// 先创建节点</span></span><br><span class="line">		HeroNode h1 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">"宋江"</span>, <span class="string">"及时雨"</span>);</span><br><span class="line">		HeroNode h2 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">"卢俊义"</span>, <span class="string">"玉麒麟"</span>);</span><br><span class="line">		HeroNode h3 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">"吴用"</span>, <span class="string">"智多星"</span>);</span><br><span class="line">		HeroNode h4 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">"林冲"</span>, <span class="string">"豹子头"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建一个链表</span></span><br><span class="line">		SingleLinkedList singleLinkedList = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 加入</span></span><br><span class="line">		singleLinkedList.addByOrder(h1);</span><br><span class="line">		singleLinkedList.addByOrder(h2);</span><br><span class="line">		singleLinkedList.addByOrder(h3);</span><br><span class="line">		singleLinkedList.addByOrder(h4);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 显示</span></span><br><span class="line">		singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 删除</span></span><br><span class="line">		singleLinkedList.del(<span class="number">1</span>);</span><br><span class="line">		singleLinkedList.del(<span class="number">4</span>);</span><br><span class="line">		singleLinkedList.del(<span class="number">2</span>);</span><br><span class="line">		singleLinkedList.del(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 显示修改过后的结果</span></span><br><span class="line">		singleLinkedList.list();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义SingleLinkedList管理我们的英雄</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 先初始化一个头节点，头节点不要动，不存放具体的数据</span></span><br><span class="line">	<span class="keyword">private</span> HeroNode head = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 添加节点到单向链表 思路，不考虑编号顺序时 </span></span><br><span class="line"><span class="comment">	 1.找到当前链表的最后节点 </span></span><br><span class="line"><span class="comment">	 2.将这个节点的next指向新的节点</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 因为head节点不能动，因此我们需要一个辅助变量temp</span></span><br><span class="line">		HeroNode temp = head;</span><br><span class="line">		<span class="comment">// 遍历链表，找到最后</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">// 找到链表的最后</span></span><br><span class="line">			<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果没有找到最后，就将temp后移</span></span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 当退出while循环的时候，temp就指向了链表的最后</span></span><br><span class="line">		temp.next = heroNode;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第二种方式在添加英雄时，根据排名将英雄插入到指定的位置</span></span><br><span class="line">	<span class="comment">// 将最后这个节点的next 指向新的节点</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助我们找到添加的位置</span></span><br><span class="line">		<span class="comment">// 因为单链表，因此我们找的temp是位于添加位置的前一个节点，否则插入不了</span></span><br><span class="line">		HeroNode temp = head;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">// flag标志添加的编号是否存在，默认为false</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;<span class="comment">// 说明temp已经在链表的最后</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;<span class="comment">// 位置找到了，就在temp的后面插入</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;<span class="comment">// 说明希望添加的heroNode的编号已经存在</span></span><br><span class="line">				flag = <span class="keyword">true</span>; <span class="comment">// 说明编号存在</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.next;<span class="comment">// 后移，遍历链表</span></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 判断flag的值</span></span><br><span class="line">		<span class="keyword">if</span> (flag) &#123;<span class="comment">// 不能添加，说明编号存在</span></span><br><span class="line">			System.out.printf(<span class="string">"准备插入的英雄%d已经存在了，不能加入\n"</span>, heroNode.no);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 插入到链表中，temp后面</span></span><br><span class="line">			heroNode.next = temp.next;</span><br><span class="line">			temp.next = heroNode;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 修改节点的信息，根据no编号来修改，即no编号不能改</span></span><br><span class="line">	<span class="comment">// 说明:</span></span><br><span class="line">	<span class="comment">// 1.根据newHeroNode的no来修改</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode newHeroNode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断是否为空</span></span><br><span class="line">		<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 找到需要修改的节点，根据no编号</span></span><br><span class="line">		<span class="comment">// 定义一个辅助变量</span></span><br><span class="line">		HeroNode temp = head.next;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">// 表示是否找到该节点</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">// 已经遍历完链表了</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;</span><br><span class="line">				<span class="comment">// 找到了</span></span><br><span class="line">				flag = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.next;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 根据flag判断是否找到</span></span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="keyword">true</span>) &#123;</span><br><span class="line">			temp.name = newHeroNode.name;</span><br><span class="line">			temp.nickname = newHeroNode.nickname;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;<span class="comment">// 没有找到</span></span><br><span class="line">			System.out.printf(<span class="string">"没有找到编号%d的节点，不能修改\n"</span>, newHeroNode.no);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除节点</span></span><br><span class="line">	<span class="comment">// 思路</span></span><br><span class="line">	<span class="comment">// 1.head不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点</span></span><br><span class="line">	<span class="comment">// 2.说明我们在比较时，是temp.next.no 和 需要删除节点的no比较</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		HeroNode temp = head;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">// 标志是否站到待删除节点的前一个节点</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (temp.next.no == no) &#123;</span><br><span class="line">				flag = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.next;<span class="comment">// temp后移，遍历</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 判断flag</span></span><br><span class="line">		<span class="keyword">if</span> (flag) &#123;<span class="comment">// 找到</span></span><br><span class="line">			<span class="comment">// 可以删除</span></span><br><span class="line">			temp.next = temp.next.next;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.printf(<span class="string">"要删除的%d节点不存在"</span>, no);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示链表 通过遍历来完成</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断链表是否为空</span></span><br><span class="line">		<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">		HeroNode temp = head.next;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">// 判断是否为空</span></span><br><span class="line">			<span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 输出节点的信息</span></span><br><span class="line">			System.out.println(temp);</span><br><span class="line">			<span class="comment">// 将temp后移，一定要小心</span></span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义HeroNode，每一个HeroNode的对象就是一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="keyword">public</span> String nickname;</span><br><span class="line">	<span class="keyword">public</span> HeroNode next;<span class="comment">// 指向下一个节点</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.no = no;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为了显示方法，我们重写toString方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">", nickname="</span></span><br><span class="line">				+ nickname + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-单向链表有效节点的个数"><a href="#8-单向链表有效节点的个数" class="headerlink" title="8.单向链表有效节点的个数"></a>8.单向链表有效节点的个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedListDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 进行测试</span></span><br><span class="line">		<span class="comment">// 先创建节点</span></span><br><span class="line">		HeroNode h1 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">"宋江"</span>, <span class="string">"及时雨"</span>);</span><br><span class="line">		HeroNode h2 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">"卢俊义"</span>, <span class="string">"玉麒麟"</span>);</span><br><span class="line">		HeroNode h3 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">"吴用"</span>, <span class="string">"智多星"</span>);</span><br><span class="line">		HeroNode h4 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">"林冲"</span>, <span class="string">"豹子头"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建一个链表</span></span><br><span class="line">		SingleLinkedList singleLinkedList = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 加入</span></span><br><span class="line">		singleLinkedList.addByOrder(h1);</span><br><span class="line">		singleLinkedList.addByOrder(h2);</span><br><span class="line">		singleLinkedList.addByOrder(h3);</span><br><span class="line">		singleLinkedList.addByOrder(h4);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 显示</span></span><br><span class="line">		singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 输出有效节点的个数</span></span><br><span class="line">		System.out.println(<span class="string">"有效节点的个数="</span> + getLength(singleLinkedList.getHead()));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 方法:获取到单向链表的节点的个数(如果是带头节点的链表，需要不统计头节点)</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">	 *            链表的头节点</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 返回的就是有效节点的个数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">		HeroNode cur = head.next;</span><br><span class="line">		<span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">			length++;</span><br><span class="line">			cur = cur.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> length;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义SingleLinkedList管理我们的英雄</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 先初始化一个头节点，头节点不要动，不存放具体的数据</span></span><br><span class="line">	<span class="keyword">private</span> HeroNode head = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回头节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> HeroNode <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 添加节点到单向链表 思路，不考虑编号顺序时 1.找到当前链表的最后节点 2.将这个节点的next指向新的节点</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 因为head节点不能动，因此我们需要一个辅助变量temp</span></span><br><span class="line">		HeroNode temp = head;</span><br><span class="line">		<span class="comment">// 遍历链表，找到最后</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">// 找到链表的最后</span></span><br><span class="line">			<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果没有找到最后，就将temp后移</span></span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 当退出while循环的时候，temp就指向了链表的最后</span></span><br><span class="line">		temp.next = heroNode;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第二种方式在添加英雄时，根据排名将英雄插入到指定的位置</span></span><br><span class="line">	<span class="comment">// 将最后这个节点的next 指向新的节点</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助我们找到添加的位置</span></span><br><span class="line">		<span class="comment">// 因为单链表，因此我们找的temp是位于添加位置的前一个节点，否则插入不了</span></span><br><span class="line">		HeroNode temp = head;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">// flag标志添加的编号是否存在，默认为false</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;<span class="comment">// 说明temp已经在链表的最后</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;<span class="comment">// 位置找到了，就在temp的后面插入</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;<span class="comment">// 说明希望添加的heroNode的编号已经存在</span></span><br><span class="line">				flag = <span class="keyword">true</span>; <span class="comment">// 说明编号存在</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.next;<span class="comment">// 后移，遍历链表</span></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 判断flag的值</span></span><br><span class="line">		<span class="keyword">if</span> (flag) &#123;<span class="comment">// 不能添加，说明编号存在</span></span><br><span class="line">			System.out.printf(<span class="string">"准备插入的英雄%d已经存在了，不能加入\n"</span>, heroNode.no);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 插入到链表中，temp后面</span></span><br><span class="line">			heroNode.next = temp.next;</span><br><span class="line">			temp.next = heroNode;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 修改节点的信息，根据no编号来修改，即no编号不能改</span></span><br><span class="line">	<span class="comment">// 说明:</span></span><br><span class="line">	<span class="comment">// 1.根据newHeroNode的no来修改</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode newHeroNode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断是否为空</span></span><br><span class="line">		<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 找到需要修改的节点，根据no编号</span></span><br><span class="line">		<span class="comment">// 定义一个辅助变量</span></span><br><span class="line">		HeroNode temp = head.next;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">// 表示是否找到该节点</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">// 已经遍历完链表了</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;</span><br><span class="line">				<span class="comment">// 找到了</span></span><br><span class="line">				flag = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.next;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 根据flag判断是否找到</span></span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="keyword">true</span>) &#123;</span><br><span class="line">			temp.name = newHeroNode.name;</span><br><span class="line">			temp.nickname = newHeroNode.nickname;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;<span class="comment">// 没有找到</span></span><br><span class="line">			System.out.printf(<span class="string">"没有找到编号%d的节点，不能修改\n"</span>, newHeroNode.no);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除节点</span></span><br><span class="line">	<span class="comment">// 思路</span></span><br><span class="line">	<span class="comment">// 1.head不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点</span></span><br><span class="line">	<span class="comment">// 2.说明我们在比较时，是temp.next.no 和 需要删除节点的no比较</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		HeroNode temp = head;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">// 标志是否站到待删除节点的前一个节点</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (temp.next.no == no) &#123;</span><br><span class="line">				flag = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.next;<span class="comment">// temp后移，遍历</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 判断flag</span></span><br><span class="line">		<span class="keyword">if</span> (flag) &#123;<span class="comment">// 找到</span></span><br><span class="line">			<span class="comment">// 可以删除</span></span><br><span class="line">			temp.next = temp.next.next;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.printf(<span class="string">"要删除的%d节点不存在"</span>, no);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示链表 通过遍历来完成</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断链表是否为空</span></span><br><span class="line">		<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">		HeroNode temp = head.next;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">// 判断是否为空</span></span><br><span class="line">			<span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 输出节点的信息</span></span><br><span class="line">			System.out.println(temp);</span><br><span class="line">			<span class="comment">// 将temp后移，一定要小心</span></span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义HeroNode，每一个HeroNode的对象就是一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="keyword">public</span> String nickname;</span><br><span class="line">	<span class="keyword">public</span> HeroNode next;<span class="comment">// 指向下一个节点</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.no = no;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为了显示方法，我们重写toString方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">", nickname="</span></span><br><span class="line">				+ nickname + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="9-查找单向链表中的倒数第K个节点【新浪】"><a href="#9-查找单向链表中的倒数第K个节点【新浪】" class="headerlink" title="9.查找单向链表中的倒数第K个节点【新浪】"></a>9.查找单向链表中的倒数第K个节点【新浪】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedListDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 进行测试</span></span><br><span class="line">		<span class="comment">// 先创建节点</span></span><br><span class="line">		HeroNode h1 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">"宋江"</span>, <span class="string">"及时雨"</span>);</span><br><span class="line">		HeroNode h2 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">"卢俊义"</span>, <span class="string">"玉麒麟"</span>);</span><br><span class="line">		HeroNode h3 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">"吴用"</span>, <span class="string">"智多星"</span>);</span><br><span class="line">		HeroNode h4 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">"林冲"</span>, <span class="string">"豹子头"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建一个链表</span></span><br><span class="line">		SingleLinkedList singleLinkedList = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 加入</span></span><br><span class="line">		singleLinkedList.addByOrder(h1);</span><br><span class="line">		singleLinkedList.addByOrder(h2);</span><br><span class="line">		singleLinkedList.addByOrder(h3);</span><br><span class="line">		singleLinkedList.addByOrder(h4);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 显示</span></span><br><span class="line">		singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 显示倒数第k个元素</span></span><br><span class="line">		System.out.println(<span class="string">"倒数第7个节点="</span> + findLastIndexNode(singleLinkedList.getHead(), <span class="number">7</span>));</span><br><span class="line">		System.out.println(<span class="string">"倒数第2个节点="</span> + findLastIndexNode(singleLinkedList.getHead(), <span class="number">2</span>));</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 查找单向链表中倒数第k个节点【新浪面试题】 思路 1.编写一个方法接收head节点，同时接收一个index</span></span><br><span class="line"><span class="comment">	 * 2.index表示的是倒数第index个节点 3.先把链表从头到尾遍历，得到链表的总长度getLength</span></span><br><span class="line"><span class="comment">	 * 4.得到size之后，我们从链表的第一个开始遍历(size-index)个，就可以得到 5.如果找到了，则返回该节点，否则返回null</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title">findLastIndexNode</span><span class="params">(HeroNode head, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断如果链表为空，直接返回null</span></span><br><span class="line">		<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 第一次遍历得到链表的长度(节点个数)</span></span><br><span class="line">		<span class="keyword">int</span> size = getLength(head);</span><br><span class="line">		<span class="comment">// 第二次遍历 size-index 位置，就是我们倒数第k个节点</span></span><br><span class="line">		<span class="comment">// 先做一个index校验</span></span><br><span class="line">		<span class="keyword">if</span> (index &lt;= <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 定义一个辅助变量,for循环定位到倒数的index</span></span><br><span class="line">		HeroNode cur = head.next;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (size - index); i++) &#123;</span><br><span class="line">			cur = cur.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cur;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 方法:获取到单向链表的节点的个数(如果是带头节点的链表，需要不统计头节点)</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">	 *            链表的头节点</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 返回的就是有效节点的个数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">		HeroNode cur = head.next;</span><br><span class="line">		<span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">			length++;</span><br><span class="line">			cur = cur.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> length;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义SingleLinkedList管理我们的英雄</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 先初始化一个头节点，头节点不要动，不存放具体的数据</span></span><br><span class="line">	<span class="keyword">private</span> HeroNode head = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回头节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> HeroNode <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 添加节点到单向链表 思路，不考虑编号顺序时 1.找到当前链表的最后节点 2.将这个节点的next指向新的节点</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 因为head节点不能动，因此我们需要一个辅助变量temp</span></span><br><span class="line">		HeroNode temp = head;</span><br><span class="line">		<span class="comment">// 遍历链表，找到最后</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">// 找到链表的最后</span></span><br><span class="line">			<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果没有找到最后，就将temp后移</span></span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 当退出while循环的时候，temp就指向了链表的最后</span></span><br><span class="line">		temp.next = heroNode;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第二种方式在添加英雄时，根据排名将英雄插入到指定的位置</span></span><br><span class="line">	<span class="comment">// 将最后这个节点的next 指向新的节点</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助我们找到添加的位置</span></span><br><span class="line">		<span class="comment">// 因为单链表，因此我们找的temp是位于添加位置的前一个节点，否则插入不了</span></span><br><span class="line">		HeroNode temp = head;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">// flag标志添加的编号是否存在，默认为false</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;<span class="comment">// 说明temp已经在链表的最后</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;<span class="comment">// 位置找到了，就在temp的后面插入</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;<span class="comment">// 说明希望添加的heroNode的编号已经存在</span></span><br><span class="line">				flag = <span class="keyword">true</span>; <span class="comment">// 说明编号存在</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.next;<span class="comment">// 后移，遍历链表</span></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 判断flag的值</span></span><br><span class="line">		<span class="keyword">if</span> (flag) &#123;<span class="comment">// 不能添加，说明编号存在</span></span><br><span class="line">			System.out.printf(<span class="string">"准备插入的英雄%d已经存在了，不能加入\n"</span>, heroNode.no);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 插入到链表中，temp后面</span></span><br><span class="line">			heroNode.next = temp.next;</span><br><span class="line">			temp.next = heroNode;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 修改节点的信息，根据no编号来修改，即no编号不能改</span></span><br><span class="line">	<span class="comment">// 说明:</span></span><br><span class="line">	<span class="comment">// 1.根据newHeroNode的no来修改</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode newHeroNode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断是否为空</span></span><br><span class="line">		<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 找到需要修改的节点，根据no编号</span></span><br><span class="line">		<span class="comment">// 定义一个辅助变量</span></span><br><span class="line">		HeroNode temp = head.next;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">// 表示是否找到该节点</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">// 已经遍历完链表了</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;</span><br><span class="line">				<span class="comment">// 找到了</span></span><br><span class="line">				flag = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.next;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 根据flag判断是否找到</span></span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="keyword">true</span>) &#123;</span><br><span class="line">			temp.name = newHeroNode.name;</span><br><span class="line">			temp.nickname = newHeroNode.nickname;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;<span class="comment">// 没有找到</span></span><br><span class="line">			System.out.printf(<span class="string">"没有找到编号%d的节点，不能修改\n"</span>, newHeroNode.no);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除节点</span></span><br><span class="line">	<span class="comment">// 思路</span></span><br><span class="line">	<span class="comment">// 1.head不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点</span></span><br><span class="line">	<span class="comment">// 2.说明我们在比较时，是temp.next.no 和 需要删除节点的no比较</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		HeroNode temp = head;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">// 标志是否站到待删除节点的前一个节点</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (temp.next.no == no) &#123;</span><br><span class="line">				flag = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.next;<span class="comment">// temp后移，遍历</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 判断flag</span></span><br><span class="line">		<span class="keyword">if</span> (flag) &#123;<span class="comment">// 找到</span></span><br><span class="line">			<span class="comment">// 可以删除</span></span><br><span class="line">			temp.next = temp.next.next;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.printf(<span class="string">"要删除的%d节点不存在"</span>, no);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示链表 通过遍历来完成</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断链表是否为空</span></span><br><span class="line">		<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">		HeroNode temp = head.next;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">// 判断是否为空</span></span><br><span class="line">			<span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 输出节点的信息</span></span><br><span class="line">			System.out.println(temp);</span><br><span class="line">			<span class="comment">// 将temp后移，一定要小心</span></span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义HeroNode，每一个HeroNode的对象就是一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="keyword">public</span> String nickname;</span><br><span class="line">	<span class="keyword">public</span> HeroNode next;<span class="comment">// 指向下一个节点</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.no = no;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为了显示方法，我们重写toString方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">", nickname="</span></span><br><span class="line">				+ nickname + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-单向链表的翻转【腾讯】"><a href="#10-单向链表的翻转【腾讯】" class="headerlink" title="10.单向链表的翻转【腾讯】"></a>10.单向链表的翻转【腾讯】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	思路</span></span><br><span class="line"><span class="comment">	1.先定义一个节点reverseHead = new HeroNode();</span></span><br><span class="line"><span class="comment">	2.从头到尾遍历原来的链表，每遍历一个节点，，就将其取出，并放在新的链表reverseHead的最前端</span></span><br><span class="line"><span class="comment">	3.原来的链表的head.next = reverseHead.next;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedListDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 进行测试</span></span><br><span class="line">		<span class="comment">// 先创建节点</span></span><br><span class="line">		HeroNode h1 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">"宋江"</span>, <span class="string">"及时雨"</span>);</span><br><span class="line">		HeroNode h2 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">"卢俊义"</span>, <span class="string">"玉麒麟"</span>);</span><br><span class="line">		HeroNode h3 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">"吴用"</span>, <span class="string">"智多星"</span>);</span><br><span class="line">		HeroNode h4 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">"林冲"</span>, <span class="string">"豹子头"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建一个链表</span></span><br><span class="line">		SingleLinkedList singleLinkedList = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 加入</span></span><br><span class="line">		singleLinkedList.addByOrder(h1);</span><br><span class="line">		singleLinkedList.addByOrder(h2);</span><br><span class="line">		singleLinkedList.addByOrder(h3);</span><br><span class="line">		singleLinkedList.addByOrder(h4);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 显示</span></span><br><span class="line">		System.out.println(<span class="string">"链表原来的样子"</span>);</span><br><span class="line">		singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 翻转链表</span></span><br><span class="line">		reverseList(singleLinkedList.getHead());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 显示翻转之后的链表</span></span><br><span class="line">		System.out.println(<span class="string">"链表翻转之后的样子"</span>);</span><br><span class="line">		singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将单向链表翻转</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverseList</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 如果当前链表为空，或者只有一个节点，无需翻转，直接返回</span></span><br><span class="line">		<span class="keyword">if</span> (head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 定义一个辅助的指针(变量)，帮助我们遍历原来的链表</span></span><br><span class="line">		HeroNode cur = head.next;</span><br><span class="line">		HeroNode next = <span class="keyword">null</span>;<span class="comment">// 指向当前节点[cur]的下一个节点</span></span><br><span class="line">		HeroNode reverseHead = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line">		<span class="comment">// 遍历原来的链表。每遍历一个节点，就将其取出，并放在新的链表reverseHead的最前端</span></span><br><span class="line">		<span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">			next = cur.next;<span class="comment">// 先暂时保存当前节点的下一个节点，因为后面需要使用</span></span><br><span class="line">			cur.next = reverseHead.next;<span class="comment">// 将cur的下一个节点指向新的链表的第一个元素(不是头元素)</span></span><br><span class="line">			reverseHead.next = cur; <span class="comment">// 将cur连接到新的链表上</span></span><br><span class="line">			cur = next;<span class="comment">// 让cur后移</span></span><br><span class="line">		&#125;</span><br><span class="line">       	</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将head.next 指向 reverseHead.next ,实现单向链表的翻转</span></span><br><span class="line">		head.next = reverseHead.next;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 查找单向链表中倒数第k个节点【新浪面试题】 思路 1.编写一个方法接收head节点，同时接收一个index</span></span><br><span class="line"><span class="comment">	 * 2.index表示的是倒数第index个节点 3.先把链表从头到尾遍历，得到链表的总长度getLength</span></span><br><span class="line"><span class="comment">	 * 4.得到size之后，我们从链表的第一个开始遍历(size-index)个，就可以得到 5.如果找到了，则返回该节点，否则返回null</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title">findLastIndexNode</span><span class="params">(HeroNode head, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断如果链表为空，直接返回null</span></span><br><span class="line">		<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 第一次遍历得到链表的长度(节点个数)</span></span><br><span class="line">		<span class="keyword">int</span> size = getLength(head);</span><br><span class="line">		<span class="comment">// 第二次遍历 size-index 位置，就是我们倒数第k个节点</span></span><br><span class="line">		<span class="comment">// 先做一个index校验</span></span><br><span class="line">		<span class="keyword">if</span> (index &lt;= <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 定义一个辅助变量,for循环定位到倒数的index</span></span><br><span class="line">		HeroNode cur = head.next;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (size - index); i++) &#123;</span><br><span class="line">			cur = cur.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cur;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 方法:获取到单向链表的节点的个数(如果是带头节点的链表，需要不统计头节点)</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">	 *            链表的头节点</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 返回的就是有效节点的个数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">		HeroNode cur = head.next;</span><br><span class="line">		<span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">			length++;</span><br><span class="line">			cur = cur.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> length;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义SingleLinkedList管理我们的英雄</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 先初始化一个头节点，头节点不要动，不存放具体的数据</span></span><br><span class="line">	<span class="keyword">private</span> HeroNode head = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回头节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> HeroNode <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 添加节点到单向链表 思路，不考虑编号顺序时 1.找到当前链表的最后节点 2.将这个节点的next指向新的节点</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 因为head节点不能动，因此我们需要一个辅助变量temp</span></span><br><span class="line">		HeroNode temp = head;</span><br><span class="line">		<span class="comment">// 遍历链表，找到最后</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">// 找到链表的最后</span></span><br><span class="line">			<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果没有找到最后，就将temp后移</span></span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 当退出while循环的时候，temp就指向了链表的最后</span></span><br><span class="line">		temp.next = heroNode;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第二种方式在添加英雄时，根据排名将英雄插入到指定的位置</span></span><br><span class="line">	<span class="comment">// 将最后这个节点的next 指向新的节点</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助我们找到添加的位置</span></span><br><span class="line">		<span class="comment">// 因为单链表，因此我们找的temp是位于添加位置的前一个节点，否则插入不了</span></span><br><span class="line">		HeroNode temp = head;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">// flag标志添加的编号是否存在，默认为false</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;<span class="comment">// 说明temp已经在链表的最后</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;<span class="comment">// 位置找到了，就在temp的后面插入</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;<span class="comment">// 说明希望添加的heroNode的编号已经存在</span></span><br><span class="line">				flag = <span class="keyword">true</span>; <span class="comment">// 说明编号存在</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.next;<span class="comment">// 后移，遍历链表</span></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 判断flag的值</span></span><br><span class="line">		<span class="keyword">if</span> (flag) &#123;<span class="comment">// 不能添加，说明编号存在</span></span><br><span class="line">			System.out.printf(<span class="string">"准备插入的英雄%d已经存在了，不能加入\n"</span>, heroNode.no);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 插入到链表中，temp后面</span></span><br><span class="line">			heroNode.next = temp.next;</span><br><span class="line">			temp.next = heroNode;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 修改节点的信息，根据no编号来修改，即no编号不能改</span></span><br><span class="line">	<span class="comment">// 说明:</span></span><br><span class="line">	<span class="comment">// 1.根据newHeroNode的no来修改</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode newHeroNode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断是否为空</span></span><br><span class="line">		<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 找到需要修改的节点，根据no编号</span></span><br><span class="line">		<span class="comment">// 定义一个辅助变量</span></span><br><span class="line">		HeroNode temp = head.next;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">// 表示是否找到该节点</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">// 已经遍历完链表了</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;</span><br><span class="line">				<span class="comment">// 找到了</span></span><br><span class="line">				flag = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.next;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 根据flag判断是否找到</span></span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="keyword">true</span>) &#123;</span><br><span class="line">			temp.name = newHeroNode.name;</span><br><span class="line">			temp.nickname = newHeroNode.nickname;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;<span class="comment">// 没有找到</span></span><br><span class="line">			System.out.printf(<span class="string">"没有找到编号%d的节点，不能修改\n"</span>, newHeroNode.no);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除节点</span></span><br><span class="line">	<span class="comment">// 思路</span></span><br><span class="line">	<span class="comment">// 1.head不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点</span></span><br><span class="line">	<span class="comment">// 2.说明我们在比较时，是temp.next.no 和 需要删除节点的no比较</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		HeroNode temp = head;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">// 标志是否站到待删除节点的前一个节点</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (temp.next.no == no) &#123;</span><br><span class="line">				flag = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.next;<span class="comment">// temp后移，遍历</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 判断flag</span></span><br><span class="line">		<span class="keyword">if</span> (flag) &#123;<span class="comment">// 找到</span></span><br><span class="line">			<span class="comment">// 可以删除</span></span><br><span class="line">			temp.next = temp.next.next;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.printf(<span class="string">"要删除的%d节点不存在"</span>, no);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示链表 通过遍历来完成</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断链表是否为空</span></span><br><span class="line">		<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">		HeroNode temp = head.next;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">// 判断是否为空</span></span><br><span class="line">			<span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 输出节点的信息</span></span><br><span class="line">			System.out.println(temp);</span><br><span class="line">			<span class="comment">// 将temp后移，一定要小心</span></span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义HeroNode，每一个HeroNode的对象就是一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="keyword">public</span> String nickname;</span><br><span class="line">	<span class="keyword">public</span> HeroNode next;<span class="comment">// 指向下一个节点</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.no = no;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为了显示方法，我们重写toString方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">", nickname="</span></span><br><span class="line">				+ nickname + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="11-从尾到头打印单向链表【百度】"><a href="#11-从尾到头打印单向链表【百度】" class="headerlink" title="11.从尾到头打印单向链表【百度】"></a>11.从尾到头打印单向链表【百度】</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	思路</span></span><br><span class="line"><span class="comment">	1.方式1：先将单向链表进行翻转操作，然后在遍历即可，这样做的问题是会破坏原来单向链表的结构，不建议</span></span><br><span class="line"><span class="comment">	2.方式2：可以利用栈这个数据结构，将各个节点压入栈中，然后利用栈的先进后出的特点，就是实现了逆序打印</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedListDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 进行测试</span></span><br><span class="line">		<span class="comment">// 先创建节点</span></span><br><span class="line">		HeroNode h1 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">"宋江"</span>, <span class="string">"及时雨"</span>);</span><br><span class="line">		HeroNode h2 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">"卢俊义"</span>, <span class="string">"玉麒麟"</span>);</span><br><span class="line">		HeroNode h3 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">"吴用"</span>, <span class="string">"智多星"</span>);</span><br><span class="line">		HeroNode h4 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">"林冲"</span>, <span class="string">"豹子头"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建一个链表</span></span><br><span class="line">		SingleLinkedList singleLinkedList = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 加入</span></span><br><span class="line">		singleLinkedList.addByOrder(h1);</span><br><span class="line">		singleLinkedList.addByOrder(h2);</span><br><span class="line">		singleLinkedList.addByOrder(h3);</span><br><span class="line">		singleLinkedList.addByOrder(h4);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 显示</span></span><br><span class="line">		System.out.println(<span class="string">"链表原来的样子"</span>);</span><br><span class="line">		singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 逆序打印</span></span><br><span class="line">		System.out.println(<span class="string">"链表逆序打印后的样子，没有改变链表本身的结构"</span>);</span><br><span class="line">		reversePrint(singleLinkedList.getHead());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 方式2：可以利用栈这个数据结构，将各个节点压入栈中，然后利用栈的先进后出的特点，就是实现了逆序打印</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversePrint</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;<span class="comment">// 空链表，不能打印</span></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 创建一个栈，将各个节点压入栈中</span></span><br><span class="line">		Stack&lt;HeroNode&gt; stack = <span class="keyword">new</span> Stack&lt;HeroNode&gt;();</span><br><span class="line">		HeroNode cur = head.next;</span><br><span class="line">		<span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">			stack.push(cur);</span><br><span class="line">			cur = cur.next;<span class="comment">// cur后移，这样就可以压入下一个节点</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将栈中的节点进行打印，pop 出栈</span></span><br><span class="line">		<span class="keyword">while</span> (stack.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			System.out.println(stack.pop());<span class="comment">// stack 栈 的特点是先进后出</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将单向链表翻转</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverseList</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 如果当前链表为空，或者只有一个节点，无需翻转，直接返回</span></span><br><span class="line">		<span class="keyword">if</span> (head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 定义一个辅助的指针(变量)，帮助我们遍历原来的链表</span></span><br><span class="line">		HeroNode cur = head.next;</span><br><span class="line">		HeroNode next = <span class="keyword">null</span>;<span class="comment">// 指向当前节点[cur]的下一个节点</span></span><br><span class="line">		HeroNode reverseHead = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line">		<span class="comment">// 遍历原来的链表。每遍历一个节点，就将其取出，并放在新的链表reverseHead的最前端</span></span><br><span class="line">		<span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">			next = cur.next;<span class="comment">// 先暂时保存当前节点的下一个节点，因为后面需要使用</span></span><br><span class="line"></span><br><span class="line">			cur.next = reverseHead.next;<span class="comment">// 将cur的下一个节点指向新的链表的第一个元素(不是头元素)</span></span><br><span class="line">			reverseHead.next = cur; <span class="comment">// 将cur连接到新的链表上</span></span><br><span class="line"></span><br><span class="line">			cur = next;<span class="comment">// 让cur后移</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将head.next 指向 reverseHead.next ,实现单向链表的翻转</span></span><br><span class="line">		head.next = reverseHead.next;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 查找单向链表中倒数第k个节点【新浪面试题】 思路 1.编写一个方法接收head节点，同时接收一个index</span></span><br><span class="line"><span class="comment">	 * 2.index表示的是倒数第index个节点 3.先把链表从头到尾遍历，得到链表的总长度getLength</span></span><br><span class="line"><span class="comment">	 * 4.得到size之后，我们从链表的第一个开始遍历(size-index)个，就可以得到 5.如果找到了，则返回该节点，否则返回null</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title">findLastIndexNode</span><span class="params">(HeroNode head, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断如果链表为空，直接返回null</span></span><br><span class="line">		<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 第一次遍历得到链表的长度(节点个数)</span></span><br><span class="line">		<span class="keyword">int</span> size = getLength(head);</span><br><span class="line">		<span class="comment">// 第二次遍历 size-index 位置，就是我们倒数第k个节点</span></span><br><span class="line">		<span class="comment">// 先做一个index校验</span></span><br><span class="line">		<span class="keyword">if</span> (index &lt;= <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 定义一个辅助变量,for循环定位到倒数的index</span></span><br><span class="line">		HeroNode cur = head.next;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (size - index); i++) &#123;</span><br><span class="line">			cur = cur.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cur;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 方法:获取到单向链表的节点的个数(如果是带头节点的链表，需要不统计头节点)</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">	 *            链表的头节点</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 返回的就是有效节点的个数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">		HeroNode cur = head.next;</span><br><span class="line">		<span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">			length++;</span><br><span class="line">			cur = cur.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> length;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义SingleLinkedList管理我们的英雄</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 先初始化一个头节点，头节点不要动，不存放具体的数据</span></span><br><span class="line">	<span class="keyword">private</span> HeroNode head = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回头节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> HeroNode <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 添加节点到单向链表 思路，不考虑编号顺序时 1.找到当前链表的最后节点 2.将这个节点的next指向新的节点</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 因为head节点不能动，因此我们需要一个辅助变量temp</span></span><br><span class="line">		HeroNode temp = head;</span><br><span class="line">		<span class="comment">// 遍历链表，找到最后</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">// 找到链表的最后</span></span><br><span class="line">			<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果没有找到最后，就将temp后移</span></span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 当退出while循环的时候，temp就指向了链表的最后</span></span><br><span class="line">		temp.next = heroNode;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第二种方式在添加英雄时，根据排名将英雄插入到指定的位置</span></span><br><span class="line">	<span class="comment">// 将最后这个节点的next 指向新的节点</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助我们找到添加的位置</span></span><br><span class="line">		<span class="comment">// 因为单链表，因此我们找的temp是位于添加位置的前一个节点，否则插入不了</span></span><br><span class="line">		HeroNode temp = head;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">// flag标志添加的编号是否存在，默认为false</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;<span class="comment">// 说明temp已经在链表的最后</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;<span class="comment">// 位置找到了，就在temp的后面插入</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;<span class="comment">// 说明希望添加的heroNode的编号已经存在</span></span><br><span class="line">				flag = <span class="keyword">true</span>; <span class="comment">// 说明编号存在</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.next;<span class="comment">// 后移，遍历链表</span></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 判断flag的值</span></span><br><span class="line">		<span class="keyword">if</span> (flag) &#123;<span class="comment">// 不能添加，说明编号存在</span></span><br><span class="line">			System.out.printf(<span class="string">"准备插入的英雄%d已经存在了，不能加入\n"</span>, heroNode.no);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 插入到链表中，temp后面</span></span><br><span class="line">			heroNode.next = temp.next;</span><br><span class="line">			temp.next = heroNode;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 修改节点的信息，根据no编号来修改，即no编号不能改</span></span><br><span class="line">	<span class="comment">// 说明:</span></span><br><span class="line">	<span class="comment">// 1.根据newHeroNode的no来修改</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode newHeroNode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断是否为空</span></span><br><span class="line">		<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 找到需要修改的节点，根据no编号</span></span><br><span class="line">		<span class="comment">// 定义一个辅助变量</span></span><br><span class="line">		HeroNode temp = head.next;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">// 表示是否找到该节点</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">// 已经遍历完链表了</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;</span><br><span class="line">				<span class="comment">// 找到了</span></span><br><span class="line">				flag = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.next;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 根据flag判断是否找到</span></span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="keyword">true</span>) &#123;</span><br><span class="line">			temp.name = newHeroNode.name;</span><br><span class="line">			temp.nickname = newHeroNode.nickname;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;<span class="comment">// 没有找到</span></span><br><span class="line">			System.out.printf(<span class="string">"没有找到编号%d的节点，不能修改\n"</span>, newHeroNode.no);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除节点</span></span><br><span class="line">	<span class="comment">// 思路</span></span><br><span class="line">	<span class="comment">// 1.head不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点</span></span><br><span class="line">	<span class="comment">// 2.说明我们在比较时，是temp.next.no 和 需要删除节点的no比较</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		HeroNode temp = head;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">// 标志是否站到待删除节点的前一个节点</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (temp.next.no == no) &#123;</span><br><span class="line">				flag = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.next;<span class="comment">// temp后移，遍历</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 判断flag</span></span><br><span class="line">		<span class="keyword">if</span> (flag) &#123;<span class="comment">// 找到</span></span><br><span class="line">			<span class="comment">// 可以删除</span></span><br><span class="line">			temp.next = temp.next.next;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.printf(<span class="string">"要删除的%d节点不存在"</span>, no);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示链表 通过遍历来完成</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断链表是否为空</span></span><br><span class="line">		<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">		HeroNode temp = head.next;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">// 判断是否为空</span></span><br><span class="line">			<span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 输出节点的信息</span></span><br><span class="line">			System.out.println(temp);</span><br><span class="line">			<span class="comment">// 将temp后移，一定要小心</span></span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义HeroNode，每一个HeroNode的对象就是一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="keyword">public</span> String nickname;</span><br><span class="line">	<span class="keyword">public</span> HeroNode next;<span class="comment">// 指向下一个节点</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.no = no;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为了显示方法，我们重写toString方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">", nickname="</span></span><br><span class="line">				+ nickname + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="12-双向链表的遍历增、删、改、查"><a href="#12-双向链表的遍历增、删、改、查" class="headerlink" title="12.双向链表的遍历增、删、改、查"></a>12.双向链表的遍历增、删、改、查</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	分析双向链表的遍历、添加、修改、删除的操作思路</span></span><br><span class="line"><span class="comment">	1.遍历 和单向链表一样，只是是可以向前查找也可以向后查找</span></span><br><span class="line"><span class="comment">	2.添加 (默认添加到双向链表的最后)</span></span><br><span class="line"><span class="comment">		(1)先找到双向链表最后的这个节点</span></span><br><span class="line"><span class="comment">		(2)temp.next = newHeroNode</span></span><br><span class="line"><span class="comment">		(3)newHeroNode.pre = temp</span></span><br><span class="line"><span class="comment">	3.修改 思路和原来的单向链表一样</span></span><br><span class="line"><span class="comment">	4.删除</span></span><br><span class="line"><span class="comment">		(1)因为是双向链表，因此，我们可以实现自我删除某个节点</span></span><br><span class="line"><span class="comment">		(2)直接找到要删除的这个节点，比如temp</span></span><br><span class="line"><span class="comment">		(3)temp.pre.next = temp.next</span></span><br><span class="line"><span class="comment">		(4)temp.next.pre = temp.pre</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedListDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 测试</span></span><br><span class="line">		System.out.println(<span class="string">"双向链表的测试"</span>);</span><br><span class="line"></span><br><span class="line">		HeroNode2 h1 = <span class="keyword">new</span> HeroNode2(<span class="number">1</span>, <span class="string">"宋江"</span>, <span class="string">"及时雨"</span>);</span><br><span class="line">		HeroNode2 h2 = <span class="keyword">new</span> HeroNode2(<span class="number">2</span>, <span class="string">"卢俊义"</span>, <span class="string">"玉麒麟"</span>);</span><br><span class="line">		HeroNode2 h3 = <span class="keyword">new</span> HeroNode2(<span class="number">3</span>, <span class="string">"吴用"</span>, <span class="string">"智多星"</span>);</span><br><span class="line">		HeroNode2 h4 = <span class="keyword">new</span> HeroNode2(<span class="number">4</span>, <span class="string">"林冲"</span>, <span class="string">"豹子头"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建双向链表</span></span><br><span class="line">		DoubleLinkedList doubleLinkedList = <span class="keyword">new</span> DoubleLinkedList();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将节点添加到双向链表当中</span></span><br><span class="line">		doubleLinkedList.add(h1);</span><br><span class="line">		doubleLinkedList.add(h2);</span><br><span class="line">		doubleLinkedList.add(h3);</span><br><span class="line">		doubleLinkedList.add(h4);</span><br><span class="line">		<span class="comment">// 显示添加之后的结果</span></span><br><span class="line">		System.out.println(<span class="string">"添加之后的结果----------------------------------"</span>);</span><br><span class="line">		doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 修改</span></span><br><span class="line">		HeroNode2 h5 = <span class="keyword">new</span> HeroNode2(<span class="number">2</span>, <span class="string">"小卢"</span>, <span class="string">"麒麟"</span>);</span><br><span class="line">		doubleLinkedList.update(h5);</span><br><span class="line">		<span class="comment">// 显示修改之后的结果</span></span><br><span class="line">		System.out.println(<span class="string">"修改之后的结果----------------------------------"</span>);</span><br><span class="line">		doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 删除</span></span><br><span class="line">		doubleLinkedList.del(<span class="number">4</span>);</span><br><span class="line">		<span class="comment">// 显示删除之后的结果</span></span><br><span class="line">		System.out.println(<span class="string">"删除之后的结果----------------------------------"</span>);</span><br><span class="line">		doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个双向链表的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 先初始化一个头节点，头节点不要动，不存放具体的数据</span></span><br><span class="line">	<span class="keyword">private</span> HeroNode2 head = <span class="keyword">new</span> HeroNode2(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回头节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> HeroNode2 <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加节点的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode2 heroNode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 因为head节点不能动，因此我们需要一个辅助变量temp</span></span><br><span class="line">		HeroNode2 temp = head;</span><br><span class="line">		<span class="comment">// 遍历链表，找到最后</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">// 找到链表的最后</span></span><br><span class="line">			<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果没有找到最后，就将temp后移</span></span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 当退出while循环的时候，temp就指向了链表的最后</span></span><br><span class="line">		<span class="comment">// 形成一个双向链表</span></span><br><span class="line">		temp.next = heroNode;</span><br><span class="line">		heroNode.pre = temp;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 修改一个节点的内容</span></span><br><span class="line">	<span class="comment">// 修改节点的信息，根据no编号来修改，即no编号不能改</span></span><br><span class="line">	<span class="comment">// 说明:</span></span><br><span class="line">	<span class="comment">// 1.根据newHeroNode的no来修改</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode2 newHeroNode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断是否为空</span></span><br><span class="line">		<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 找到需要修改的节点，根据no编号</span></span><br><span class="line">		<span class="comment">// 定义一个辅助变量</span></span><br><span class="line">		HeroNode2 temp = head.next;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">// 表示是否找到该节点</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">// 已经遍历完链表了</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;</span><br><span class="line">				<span class="comment">// 找到了</span></span><br><span class="line">				flag = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.next;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 根据flag判断是否找到</span></span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="keyword">true</span>) &#123;</span><br><span class="line">			temp.name = newHeroNode.name;</span><br><span class="line">			temp.nickname = newHeroNode.nickname;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;<span class="comment">// 没有找到</span></span><br><span class="line">			System.out.printf(<span class="string">"没有找到编号%d的节点，不能修改\n"</span>, newHeroNode.no);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除节点</span></span><br><span class="line">	<span class="comment">// 思路</span></span><br><span class="line">	<span class="comment">// 1.head不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点</span></span><br><span class="line">	<span class="comment">// 2.说明我们在比较时，是temp.next.no 和 需要删除节点的no比较</span></span><br><span class="line">	<span class="comment">// 对于双向链表，我们可以直接找到要删除的这个节点</span></span><br><span class="line">	<span class="comment">// 找到以后自我删除即可</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 判断当前列表是否为空</span></span><br><span class="line">		<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123; <span class="comment">// 空链表</span></span><br><span class="line">			System.out.println(<span class="string">"链表为空，无法删除"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		HeroNode2 temp = head.next; <span class="comment">// 辅助变量(指针)</span></span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">// 标志是否站到待删除节点的前一个节点</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;<span class="comment">// 已经到链表最后</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (temp.no == no) &#123;</span><br><span class="line">				flag = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.next;<span class="comment">// temp后移，遍历</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 判断flag</span></span><br><span class="line">		<span class="keyword">if</span> (flag) &#123;<span class="comment">// 找到</span></span><br><span class="line">			<span class="comment">// 可以删除</span></span><br><span class="line">			temp.pre.next = temp.next;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">// 这里我们的代码有问题</span></span><br><span class="line">				<span class="comment">// 如果是最后一个节点，就不需要下面这句话，否则会出现空指针异常</span></span><br><span class="line">				<span class="comment">// 所以我们加上了以上条件，如果后一个元素不为空，在执行下面这句话</span></span><br><span class="line">				temp.next.pre = temp.pre;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.printf(<span class="string">"要删除的%d节点不存在"</span>, no);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历双向链表的方法</span></span><br><span class="line">	<span class="comment">// 显示链表 通过遍历来完成</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断链表是否为空</span></span><br><span class="line">		<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">		HeroNode2 temp = head.next;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">// 判断是否为空</span></span><br><span class="line">			<span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 输出节点的信息</span></span><br><span class="line">			System.out.println(temp);</span><br><span class="line">			<span class="comment">// 将temp后移，一定要小心</span></span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义HeroNode2，每一个HeroNode的对象就是一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode2</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="keyword">public</span> String nickname;</span><br><span class="line">	<span class="keyword">public</span> HeroNode2 next;<span class="comment">// 指向下一个节点，默认为null</span></span><br><span class="line">	<span class="keyword">public</span> HeroNode2 pre;<span class="comment">// 指向前一个节点，默认为null</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HeroNode2</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.no = no;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为了显示方法，我们重写toString方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">", nickname="</span></span><br><span class="line">				+ nickname + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="13-约瑟夫问题-环形链表"><a href="#13-约瑟夫问题-环形链表" class="headerlink" title="13.约瑟夫问题(环形链表)"></a>13.约瑟夫问题(环形链表)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	构建一个单向链表的环形链表思路</span></span><br><span class="line"><span class="comment">	1.先创建第一个节点，让first指向该节点，并形成环形</span></span><br><span class="line"><span class="comment">	2.后面当我们每创建一个新的节点，就把该节点，加入到已有的环形链表即可</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	遍历环形链表</span></span><br><span class="line"><span class="comment">	1.先让一个辅助指针(变量)curBoy，指向first节点</span></span><br><span class="line"><span class="comment">	2.然后通过一个while循环遍历该环形链表即可curBoy.next==first结束</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	根据用户的输入，生成一个小孩出圈的顺序</span></span><br><span class="line"><span class="comment">	n=5,即有五个人</span></span><br><span class="line"><span class="comment">	k=1,从第一个热开始报数</span></span><br><span class="line"><span class="comment">	m=2，数2下</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	1.需要创建一个辅助指针(变量)helper,事先应该指向环形链表的最后这个节点</span></span><br><span class="line"><span class="comment">	补充：小孩报数前，显然 first 和 helper 移动 k-1 次</span></span><br><span class="line"><span class="comment">	2.当小孩报数时，让 first 和 helper 指针同时移动 m-1 次</span></span><br><span class="line"><span class="comment">	3.这时就可以将 first 指向的小孩节点出圈 </span></span><br><span class="line"><span class="comment">	first = first.next</span></span><br><span class="line"><span class="comment">	helper.next = first</span></span><br><span class="line"><span class="comment">	出圈顺序 2——&gt;4——&gt;1——&gt;5——&gt;3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Joseph</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 测试一把，看看构建环形链表和遍历是否ok</span></span><br><span class="line">		CircleSingleLinkedList circleSingleLinkedList = <span class="keyword">new</span> CircleSingleLinkedList();</span><br><span class="line">		circleSingleLinkedList.addBoy(<span class="number">5</span>);</span><br><span class="line">		circleSingleLinkedList.showBoy();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 测试一把小孩出圈的顺序是否正确</span></span><br><span class="line">		circleSingleLinkedList.counBoy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个环形的单向链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleSingleLinkedList</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 创建一个first节点，当前没有编号</span></span><br><span class="line">	<span class="keyword">private</span> Boy first = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加小孩节点，构建一个环形链表</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBoy</span><span class="params">(<span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// nums做一个数据校验</span></span><br><span class="line">		<span class="keyword">if</span> (nums &lt; <span class="number">1</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"nums的值不正确"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Boy curBoy = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">// 使用for循环来创建环形链表</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums; i++) &#123;</span><br><span class="line">			<span class="comment">// 根据编号创建小孩节点</span></span><br><span class="line">			Boy boy = <span class="keyword">new</span> Boy(i);</span><br><span class="line">			<span class="comment">// 如果是第一个小孩</span></span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">				first = boy;</span><br><span class="line">				first.setNext(first);<span class="comment">// 构成环形</span></span><br><span class="line">				curBoy = first;<span class="comment">// 让curBoy指向第一个小孩</span></span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				curBoy.setNext(boy);</span><br><span class="line">				boy.setNext(first);</span><br><span class="line">				curBoy = boy;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历当前的环形链表</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showBoy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断链表是否为空</span></span><br><span class="line">		<span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"没有任何小孩"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 因为first不能动，所以我们仍然使用一个辅助指针完成遍历</span></span><br><span class="line">		Boy curBoy = first;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			System.out.printf(<span class="string">"小孩的编号%d \n"</span>, curBoy.getNo());</span><br><span class="line">			<span class="keyword">if</span> (curBoy.getNext() == first) &#123;<span class="comment">// 说明已经遍历完毕</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			curBoy = curBoy.getNext();<span class="comment">// curBoy后移</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据用户的输入，计算小孩出圈的顺序</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> startNo</span></span><br><span class="line"><span class="comment">	 *            表示从第几个小孩开始数数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> countNum</span></span><br><span class="line"><span class="comment">	 *            表示数几下</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">	 *            表示最初有多少个小孩在圈中</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">counBoy</span><span class="params">(<span class="keyword">int</span> startNo, <span class="keyword">int</span> countNum, <span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 先对数据进行校验</span></span><br><span class="line">		<span class="keyword">if</span> (first == <span class="keyword">null</span> || startNo &lt; <span class="number">1</span> || startNo &gt; nums) &#123;</span><br><span class="line">			System.out.println(<span class="string">"参数输入有误，请重新输入"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建一个指针变量，帮助小孩完成出圈</span></span><br><span class="line">		Boy helper = first;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (helper.getNext() == first) &#123;<span class="comment">// 说明helper指向最后小孩节点</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			helper = helper.getNext();</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 小孩报数前，先让first和helper移动 startNo-1 次</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; startNo - <span class="number">1</span>; j++) &#123;</span><br><span class="line">			first = first.getNext();</span><br><span class="line">			helper = helper.getNext();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 当小孩报数时，让first和helper指针同时移动 countNum-1 次，然后出圈</span></span><br><span class="line">		<span class="comment">// 这是一个循环的操作，直到圈中只有一个节点</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (helper == first) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 让first和helper指针同时移动 countNum-1 次</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; countNum - <span class="number">1</span>; j++) &#123;</span><br><span class="line">				first = first.getNext();</span><br><span class="line">				helper = helper.getNext();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 这时first指向的节点，就是要出圈的小孩节点</span></span><br><span class="line">			System.out.printf(<span class="string">"小孩%d出圈\n"</span>, first.getNo());</span><br><span class="line">			<span class="comment">// 这时将first指向的小孩节点出圈</span></span><br><span class="line">			first = first.getNext();</span><br><span class="line">			helper.setNext(first);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.printf(<span class="string">"最后留在圈中的小孩编号%d\n"</span>, first.getNo());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Boy类，表示一个点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> no;<span class="comment">// 编号</span></span><br><span class="line">	<span class="keyword">private</span> Boy next;<span class="comment">// 指向下一个节点，默认null</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Boy</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.no = no;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> no;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.no = no;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Boy <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Boy next)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.next = next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="14-数组模拟栈"><a href="#14-数组模拟栈" class="headerlink" title="14.数组模拟栈"></a>14.数组模拟栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStackDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 测试一下 ArrayStack 是否正确</span></span><br><span class="line">		<span class="comment">// 先创建一个 ArrayStack 对象 -&gt;表示栈</span></span><br><span class="line">		ArrayStack stack = <span class="keyword">new</span> ArrayStack(<span class="number">4</span>);</span><br><span class="line">		<span class="keyword">int</span> key = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line">		Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (loop) &#123;</span><br><span class="line">			System.out.println(<span class="string">"1.show:表示显示栈"</span>);</span><br><span class="line">			System.out.println(<span class="string">"2.exit:退出程序"</span>);</span><br><span class="line">			System.out.println(<span class="string">"3.push:表示添加数据到栈(入栈)"</span>);</span><br><span class="line">			System.out.println(<span class="string">"4.pop:表示从栈取出数据(出栈)"</span>);</span><br><span class="line">			System.out.println(<span class="string">"请输入你的选择"</span>);</span><br><span class="line">			key = scanner.nextInt();</span><br><span class="line">			<span class="keyword">if</span> (key == <span class="number">1</span>) &#123;</span><br><span class="line">				stack.list();</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="number">3</span>) &#123;</span><br><span class="line">				System.out.println(<span class="string">"请输入一个数字"</span>);</span><br><span class="line">				<span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">				stack.push(value);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="number">4</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">int</span> res = stack.pop();</span><br><span class="line">					System.out.println(res);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">					System.out.println(e.getMessage());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="number">2</span>) &#123;</span><br><span class="line">				scanner.close();</span><br><span class="line">				loop = <span class="keyword">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">"输入错误，请重新输入"</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"程序退出了"</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 ArrayStack 表示栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">// 栈的大小</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] stack;<span class="comment">// 数组，数组模拟栈，数据就该放在数组</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> top = -<span class="number">1</span>;<span class="comment">// top表示栈顶，初始化为-1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">		stack = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.maxSize];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 栈满</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 栈空</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 入栈-push</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断是否栈满</span></span><br><span class="line">		<span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"栈满"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		top++;</span><br><span class="line">		stack[top] = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 出栈-pop，将栈顶的数据返回</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 先判断是否为空</span></span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">			<span class="comment">// 抛出异常</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈空,没有数据"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> value = stack[top];</span><br><span class="line">		top--;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示栈的情况</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 先判断是否为空</span></span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"栈空，没有数据"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 需要从栈顶显示数据</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = top; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			System.out.printf(<span class="string">"stack[%d]=%d\n"</span>, i, stack[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="15-使用栈完成计算表达式的结果"><a href="#15-使用栈完成计算表达式的结果" class="headerlink" title="15.使用栈完成计算表达式的结果"></a>15.使用栈完成计算表达式的结果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	使用栈完成表达式的计算思路</span></span><br><span class="line"><span class="comment">	1.通过一个index值(索引)，来遍历我们的表达式</span></span><br><span class="line"><span class="comment">	2.如果我们发现是一个数字，就直接入数栈</span></span><br><span class="line"><span class="comment">	3.如果发现扫描到的是一个符号，就分如下情况</span></span><br><span class="line"><span class="comment">		1）如果返现当期那的符号栈为空，就直接入栈</span></span><br><span class="line"><span class="comment">		2）如果符号栈有操作符，就进行比较，如果当前的操作符的优先级小于或者等于栈中的操作符，就需要从			数栈中 pop 出两个数，再从符号栈中 pop 出一个符号，进行运算，将得到结果，入数栈，然后将当前			的操作符入符号栈，如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈。</span></span><br><span class="line"><span class="comment">	4.当表达式扫描完毕，就顺序的从数栈和符号栈中 pop 出相应的数和符号，并运行。</span></span><br><span class="line"><span class="comment">	5.最后在数栈只有一个数字，就是表达式的结果</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	验证 7*2*2-5+1-5+3-4 = 18</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 根据前面老师思路，完成表达式的运算</span></span><br><span class="line">		String expression = <span class="string">"7*2*2-5+1-5+3-4"</span>; <span class="comment">// 15//如何处理多位数的问题？</span></span><br><span class="line">		<span class="comment">// 创建两个栈，数栈，一个符号栈</span></span><br><span class="line">		ArrayStack2 numStack = <span class="keyword">new</span> ArrayStack2(<span class="number">10</span>);</span><br><span class="line">		ArrayStack2 operStack = <span class="keyword">new</span> ArrayStack2(<span class="number">10</span>);</span><br><span class="line">		<span class="comment">// 定义需要的相关变量</span></span><br><span class="line">		<span class="keyword">int</span> index = <span class="number">0</span>;<span class="comment">// 用于扫描</span></span><br><span class="line">		<span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> oper = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">char</span> ch = <span class="string">' '</span>; <span class="comment">// 将每次扫描得到char保存到ch</span></span><br><span class="line">		String keepNum = <span class="string">""</span>; <span class="comment">// 用于拼接 多位数</span></span><br><span class="line">		<span class="comment">// 开始while循环的扫描expression</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">// 依次得到expression 的每一个字符</span></span><br><span class="line">			ch = expression.substring(index, index + <span class="number">1</span>).charAt(<span class="number">0</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 判断ch是什么，然后做相应的处理</span></span><br><span class="line">			<span class="keyword">if</span> (operStack.isOper(ch)) &#123;<span class="comment">// 如果是运算符</span></span><br><span class="line">				<span class="comment">// 判断当前的符号栈是否为空</span></span><br><span class="line">				<span class="keyword">if</span> (!operStack.isEmpty()) &#123;</span><br><span class="line">					<span class="comment">// 如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符,就需要从数栈中pop出两个数,</span></span><br><span class="line">					<span class="comment">// 在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈</span></span><br><span class="line">					<span class="keyword">if</span> (operStack.priority(ch) &lt;= operStack.priority(operStack.peek())) &#123;</span><br><span class="line">						num1 = numStack.pop();</span><br><span class="line">						num2 = numStack.pop();</span><br><span class="line">						oper = operStack.pop();</span><br><span class="line">						res = numStack.cal(num1, num2, oper);</span><br><span class="line">						<span class="comment">// 把运算的结果入数栈</span></span><br><span class="line">						numStack.push(res);</span><br><span class="line">						<span class="comment">// 然后将当前的操作符入符号栈</span></span><br><span class="line">						operStack.push(ch);</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">// 如果当前的操作符的优先级大于栈中的操作符， 就直接入符号栈.</span></span><br><span class="line">						operStack.push(ch);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// 如果为空直接入符号栈..</span></span><br><span class="line">					operStack.push(ch); <span class="comment">// 1 + 3</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果是数，则直接入数栈</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">// numStack.push(ch - 48); //? "1+3" '1' =&gt; 1</span></span><br><span class="line">				<span class="comment">// 分析思路</span></span><br><span class="line">				<span class="comment">// 1. 当处理多位数时，不能发现是一个数就立即入栈，因为他可能是多位数</span></span><br><span class="line">				<span class="comment">// 2. 在处理数，需要向expression的表达式的index 后再看一位,如果是数就进行扫描，如果是符号才入栈</span></span><br><span class="line">				<span class="comment">// 3. 因此我们需要定义一个变量 字符串，用于拼接</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">// 处理多位数</span></span><br><span class="line">				keepNum += ch;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 如果ch已经是expression的最后一位，就直接入栈</span></span><br><span class="line">				<span class="keyword">if</span> (index == expression.length() - <span class="number">1</span>) &#123;</span><br><span class="line">					numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 判断下一个字符是不是数字，如果是数字，就继续扫描，如果是运算符，则入栈</span></span><br><span class="line">					<span class="comment">// 注意是看后一位，不是index++</span></span><br><span class="line">					<span class="keyword">if</span> (operStack.isOper(expression.substring(index + <span class="number">1</span>,index + <span class="number">2</span>).charAt(<span class="number">0</span>))) &#123;</span><br><span class="line">						<span class="comment">// 如果后一位是运算符，则入栈 keepNum = "1" 或者 "123"</span></span><br><span class="line">						numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">						<span class="comment">// 重要的!!!!!!, keepNum清空</span></span><br><span class="line">						keepNum = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 让index + 1, 并判断是否扫描到expression最后.</span></span><br><span class="line">			index++;</span><br><span class="line">			<span class="keyword">if</span> (index &gt;= expression.length()) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 当表达式扫描完毕，就顺序的从 数栈和符号栈中pop出相应的数和符号，并运行.</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">// 如果符号栈为空，则计算到最后的结果, 数栈中只有一个数字【结果】</span></span><br><span class="line">			<span class="keyword">if</span> (operStack.isEmpty()) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			num1 = numStack.pop();</span><br><span class="line">			num2 = numStack.pop();</span><br><span class="line">			oper = operStack.pop();</span><br><span class="line">			res = numStack.cal(num1, num2, oper);</span><br><span class="line">			numStack.push(res);<span class="comment">// 入栈</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将数栈的最后数，pop出，就是结果</span></span><br><span class="line">		<span class="keyword">int</span> res2 = numStack.pop();</span><br><span class="line">		System.out.printf(<span class="string">"表达式 %s = %d"</span>, expression, res2);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先创建一个栈,直接使用前面创建好</span></span><br><span class="line"><span class="comment">// 定义一个 ArrayStack2 表示栈, 需要扩展功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStack2</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> maxSize; <span class="comment">// 栈的大小</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] stack; <span class="comment">// 数组，数组模拟栈，数据就放在该数组</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> top = -<span class="number">1</span>;<span class="comment">// top表示栈顶，初始化为-1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ArrayStack2</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">		stack = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.maxSize];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 增加一个方法，可以返回当前栈顶的值, 但是不是真正的pop</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> stack[top];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 栈满</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 栈空</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 入栈-push</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 先判断栈是否满</span></span><br><span class="line">		<span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"栈满"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		top++;</span><br><span class="line">		stack[top] = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 出栈-pop, 将栈顶的数据返回</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 先判断栈是否空</span></span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">			<span class="comment">// 抛出异常</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈空，没有数据~"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> value = stack[top];</span><br><span class="line">		top--;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示栈的情况[遍历栈]， 遍历时，需要从栈顶开始显示数据</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"栈空，没有数据~~"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 需要从栈顶开始显示数据</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = top; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			System.out.printf(<span class="string">"stack[%d]=%d\n"</span>, i, stack[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回运算符的优先级，优先级是程序员来确定, 优先级使用数字表示</span></span><br><span class="line">	<span class="comment">// 数字越大，则优先级就越高.</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">priority</span><span class="params">(<span class="keyword">int</span> oper)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (oper == <span class="string">'*'</span> || oper == <span class="string">'/'</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">'+'</span> || oper == <span class="string">'-'</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 假定目前的表达式只有 +, - , * , /</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断是不是一个运算符</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOper</span><span class="params">(<span class="keyword">char</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val == <span class="string">'+'</span> || val == <span class="string">'-'</span> || val == <span class="string">'*'</span> || val == <span class="string">'/'</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2, <span class="keyword">int</span> oper)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>; <span class="comment">// res 用于存放计算的结果</span></span><br><span class="line">		<span class="keyword">switch</span> (oper) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">			res = num1 + num2;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">			res = num2 - num1;<span class="comment">// 注意顺序</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">			res = num1 * num2;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">			res = num2 / num1;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="16-逆波兰计算器"><a href="#16-逆波兰计算器" class="headerlink" title="16.逆波兰计算器"></a>16.逆波兰计算器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	前缀、中缀、后缀表达式(逆波兰表达式)</span></span><br><span class="line"><span class="comment">	后缀表达式的计算机求值：</span></span><br><span class="line"><span class="comment">	    从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个		数，用运算符对他们做出相应的计算(次顶元素 和 栈顶元素)，并将结果入栈。重复上述过程	   直到表达式最右端，最后运算得出的值即为表达式的结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolandNotation</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 先定义一个逆波兰表达式</span></span><br><span class="line">		<span class="comment">// (3+4)*5-6 =&gt; 3 4 + 5 * 6 -</span></span><br><span class="line">		<span class="comment">// 说明：为了方便，逆波兰表达式的数字和符号使用空格隔开</span></span><br><span class="line">		String suffixExpression = <span class="string">"3 4 + 5 * 6 -"</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 思路</span></span><br><span class="line">		<span class="comment">// 1.先将 "3 4 + 5 * 6 -" =&gt; 放到ArrayList中</span></span><br><span class="line">		<span class="comment">// 2.将ArrayList传递给一个方法，遍历ArrayList配合栈完成计算</span></span><br><span class="line"></span><br><span class="line">		List&lt;String&gt; rpnList = getListString(suffixExpression);</span><br><span class="line">		System.out.println(<span class="string">"rpnList="</span> + rpnList);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> res = calculate(rpnList);</span><br><span class="line">		System.out.printf(<span class="string">"计算的结果是:%d"</span>, res);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将一个逆波兰表达式，依次将数据和运算符放入到 ArrayList中</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getListString</span><span class="params">(String suffixExpression)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 将 suffixExpression 分割</span></span><br><span class="line">		String[] split = suffixExpression.split(<span class="string">" "</span>);</span><br><span class="line">		List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		<span class="keyword">for</span> (String ele : split) &#123;</span><br><span class="line">			list.add(ele);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 完成对逆波兰表达式的运算</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 1.从左至右扫描，将 3 和 4 压入堆栈 2.遇到 + 运算符，因此弹出 4 和 3 ( 4 为栈顶元素，3 为次栈顶元素)，计算出 3+4</span></span><br><span class="line"><span class="comment">	 * 的值，得 7，再将 7 入栈 3.将 5 入栈 4.接下来是 * 运算符，因此弹出 5 和 7 ，计算出 7*5=35 ， 将 35 入栈 5.将</span></span><br><span class="line"><span class="comment">	 * 6 入栈 6.最后是 - 运算符，计算出 35-6 的值， 即 29 ，由此得出最终结果</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(List&lt;String&gt; ls)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建一个栈</span></span><br><span class="line">		Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line">		<span class="comment">// 遍历 ls</span></span><br><span class="line">		<span class="keyword">for</span> (String item : ls) &#123;</span><br><span class="line">			<span class="comment">// 这里用正则表达式来取出数</span></span><br><span class="line">			<span class="keyword">if</span> (item.matches(<span class="string">"\\d+"</span>)) &#123;<span class="comment">// 匹配的是多位数</span></span><br><span class="line">				<span class="comment">// 入栈</span></span><br><span class="line">				stack.push(item);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// pop出两个数，并运算，在入栈</span></span><br><span class="line">				<span class="keyword">int</span> num2 = Integer.parseInt(stack.pop());</span><br><span class="line">				<span class="keyword">int</span> num1 = Integer.parseInt(stack.pop());</span><br><span class="line">				<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (item.equals(<span class="string">"+"</span>)) &#123;</span><br><span class="line">					res = num1 + num2;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">					res = num1 - num2;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"*"</span>)) &#123;</span><br><span class="line">					res = num1 * num2;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"/"</span>)) &#123;</span><br><span class="line">					res = num1 / num2;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"运算符有误"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 把 res 入栈 (这里注意要把res转换成字符串，否则无法入栈)</span></span><br><span class="line">				stack.push(Integer.toString(res));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 最后留在stack中的数据是运算结果</span></span><br><span class="line">		<span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-中缀表达式转后缀表达式"><a href="#17-中缀表达式转后缀表达式" class="headerlink" title="17.中缀表达式转后缀表达式"></a>17.中缀表达式转后缀表达式</h3><blockquote>
<p>1.初始化两个栈：运算符栈s1和储存中间结果的栈s2；<br>2.从左至右扫描中缀表达式；<br>3.遇到操作数时，将其压s2；<br>4.遇到运算符时，比较其与s1栈顶运算符的优先级：<br>    1).如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；<br>    2).否则，若优先级比栈顶运算符的高，也将运算符压入s1；<br>    3).否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较；<br>5.遇到括号时：<br>(1) 如果是左括号“(”，则直接压入s1<br>(2) 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢    弃<br>6.重复步骤2至5，直到表达式的最右边</p>
<p>7.将s1中剩余的运算符依次弹出并压入s2<br>8.依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式</p>
</blockquote>
<p><strong>下面表格是中缀表达式转后缀表达式运行步骤</strong></p>
<table>
<thead>
<tr>
<th>扫描到的元素</th>
<th>s2(栈底-&gt;栈顶)</th>
<th align="left">s1(栈底-&gt;栈顶)</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td align="left">空</td>
<td>数字，直接入栈</td>
</tr>
<tr>
<td>+</td>
<td>1</td>
<td align="left">+</td>
<td>s1为空，运算符直接入栈</td>
</tr>
<tr>
<td>(</td>
<td>1</td>
<td align="left">+ (</td>
<td>左括号，直接入栈</td>
</tr>
<tr>
<td>(</td>
<td>1</td>
<td align="left">+ ( (</td>
<td>同上</td>
</tr>
<tr>
<td>2</td>
<td>1 2</td>
<td align="left">+ ( (</td>
<td>数字</td>
</tr>
<tr>
<td>+</td>
<td>1 2</td>
<td align="left">+ ( ( +</td>
<td>s1栈顶为左括号，运算符直接入栈</td>
</tr>
<tr>
<td>3</td>
<td>1 2 3</td>
<td align="left">+ ( ( +</td>
<td>数字</td>
</tr>
<tr>
<td>)</td>
<td>1 2 3 +</td>
<td align="left">+ (</td>
<td>右括号，弹出运算符直至遇到左括号</td>
</tr>
<tr>
<td>*</td>
<td>1 2 3 +</td>
<td align="left">+ ( *</td>
<td>s1栈顶为左括号</td>
</tr>
<tr>
<td>4</td>
<td>1 2 3 + 4</td>
<td align="left">+ ( *</td>
<td>数字</td>
</tr>
<tr>
<td>)</td>
<td>1 2 3 + 4 *</td>
<td align="left">+</td>
<td>右括号，弹出运算符直至遇到左括号</td>
</tr>
<tr>
<td>-</td>
<td>1 2 3 + 4 * +</td>
<td align="left">-</td>
<td>- 与 + 优先级相同，因此弹出 + ，再压入 -</td>
</tr>
<tr>
<td>5</td>
<td>1 2 3 + 4 * + 5</td>
<td align="left">-</td>
<td>数字</td>
</tr>
<tr>
<td>到达最右端</td>
<td>1 2 3 + 4 * + 5 -</td>
<td align="left">空</td>
<td>s1中剩余的运算符</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolandNotation</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 完成将一个中缀表达式转换成后缀表达式的功能</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 说明 1. 1+((2+3)*4)-5 =&gt; 转换成 1 2 3 + 4 * + 5 - 2. 因为直接对 str</span></span><br><span class="line"><span class="comment">		 * 进行操作，不方便，因此先将 "1+((2+3)*4)-5" =&gt; 转换成中缀表达式的list形式 即"1+((2+3)*4)-5" =&gt;</span></span><br><span class="line"><span class="comment">		 * ArrayList[1,+,(,(,2,+,3,),*,4,),-,5] 3.将得到的中缀表达式对应的List =&gt;</span></span><br><span class="line"><span class="comment">		 * 后缀表达式对应的List 即ArrayList[1,+,(,(,2,+,3,),*,4,),-,5] =&gt;</span></span><br><span class="line"><span class="comment">		 * ArrayList[1,2,3,+,4,*,+,5,-]</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 表达式</span></span><br><span class="line">		String expression = <span class="string">"1+((2+3)*4)-5"</span>;</span><br><span class="line">		<span class="comment">// 字符串表达式转换成中缀表达式</span></span><br><span class="line">		List&lt;String&gt; infixExpressionList = toInfixExpressionList(expression);</span><br><span class="line">		System.out.println(<span class="string">"中缀表达式对应List="</span> + infixExpressionList);<span class="comment">// ArrayList[1,+,(,(,2,+,3,),*,4,),-,5]</span></span><br><span class="line">		<span class="comment">// 中缀表达式转化成后缀表达式</span></span><br><span class="line">		List&lt;String&gt; parseSuffixExpression = parseSuffixExpression(infixExpressionList);</span><br><span class="line">		System.out.println(<span class="string">"后缀表达式对应的List"</span> + parseSuffixExpression);</span><br><span class="line">		<span class="comment">// 调用计算方法 计算出来结果输出</span></span><br><span class="line">		<span class="keyword">int</span> res = calculate(parseSuffixExpression);</span><br><span class="line">		System.out.printf(<span class="string">"计算的结果是:%d"</span>, res);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 方法：将得到的中缀表达式对应的 List =&gt; 后缀表达式对应的 List</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">parseSuffixExpression</span><span class="params">(List&lt;String&gt; ls)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 定义两个栈</span></span><br><span class="line">		Stack&lt;String&gt; s1 = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line">		<span class="comment">// 说明：因为s2这个栈，在整个转换的过程当中，没有pop操作，而且后面我们还要逆序输出，</span></span><br><span class="line">		<span class="comment">// 因此比较麻烦，这里我们就不用Stack&lt;Strig&gt;直接使用ArrayList&lt;String&gt; s2</span></span><br><span class="line">		List&lt;String&gt; s2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();<span class="comment">// 存储中间结果 List s2</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 遍历 s2</span></span><br><span class="line">		<span class="keyword">for</span> (String item : ls) &#123;</span><br><span class="line">			<span class="comment">// 如果是一个数，加入s2</span></span><br><span class="line">			<span class="keyword">if</span> (item.matches(<span class="string">"\\d+"</span>)) &#123;</span><br><span class="line">				s2.add(item);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"("</span>)) &#123;</span><br><span class="line">				s1.push(item);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">")"</span>)) &#123;</span><br><span class="line">				<span class="comment">// 如果是右括号 ，则依次弹出s1栈顶的运算符，并压入s2，知道遇到左括号为止，此时将这一对括号丢弃</span></span><br><span class="line">				<span class="keyword">while</span> (!s1.peek().equals(<span class="string">"("</span>)) &#123;<span class="comment">// peek查看栈顶的内容，但是不弹出</span></span><br><span class="line">					s2.add(s1.pop());</span><br><span class="line">				&#125;</span><br><span class="line">				s1.pop();<span class="comment">// 将左括号弹出 s1 栈，消除小括号</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 当item的优先级小于s1栈顶运算符，将s1栈顶的运算符弹出并加入到s2中，再次转到 4.1步骤 与s1的栈顶运算符做比较</span></span><br><span class="line">				<span class="keyword">while</span> (s1.size() != <span class="number">0</span> &amp;&amp; Operation.getValue(s1.peek()) &gt;= Operation.getValue(item)) &#123;</span><br><span class="line">					s2.add(s1.pop());</span><br><span class="line">				&#125;</span><br><span class="line">				s1.push(item);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将s1中剩余的运算符依次弹出，并加入到s2</span></span><br><span class="line">		<span class="keyword">while</span> (s1.size() != <span class="number">0</span>) &#123;</span><br><span class="line">			s2.add(s1.pop());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> s2;<span class="comment">// 注意，因为是存放到List，因此按顺序输出就是对应的后缀表达式对应的List</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 方法：将中缀表达式转换成相应的List</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">toInfixExpressionList</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 定义一个List，存放中缀表达式对应的内容</span></span><br><span class="line">		List&lt;String&gt; ls = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">// 这是一个指针，用来遍历中缀表达式字符串</span></span><br><span class="line">		String str;<span class="comment">// 对多位数的拼接</span></span><br><span class="line">		<span class="keyword">char</span> c;<span class="comment">// 每遍历到一个字符，就放入c</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			<span class="comment">// 如果c是一个非数字，我需要加入到ls</span></span><br><span class="line">			<span class="keyword">if</span> ((c = s.charAt(i)) &lt; <span class="number">48</span> || (c = s.charAt(i)) &gt; <span class="number">57</span>) &#123;</span><br><span class="line">				ls.add(<span class="string">""</span> + c);</span><br><span class="line">				i++;<span class="comment">// i需要后移</span></span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				str = <span class="string">""</span>;</span><br><span class="line">				<span class="keyword">while</span> (i &lt; s.length() &amp;&amp; (c = s.charAt(i)) &gt;= <span class="number">48</span></span><br><span class="line">						&amp;&amp; (c = s.charAt(i)) &lt;= <span class="number">57</span>) &#123;</span><br><span class="line">					str += c;<span class="comment">// 拼接</span></span><br><span class="line">					i++;</span><br><span class="line">				&#125;</span><br><span class="line">				ls.add(str);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">while</span> (i &lt; s.length());</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ls;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将一个逆波兰表达式，依次将数据和运算符放入到 ArrayList中</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getListString</span><span class="params">(String suffixExpression)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 将 suffixExpression 分割</span></span><br><span class="line">		String[] split = suffixExpression.split(<span class="string">" "</span>);</span><br><span class="line">		List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		<span class="keyword">for</span> (String ele : split) &#123;</span><br><span class="line">			list.add(ele);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 完成对逆波兰表达式的运算</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 1.从左至右扫描，将 3 和 4 压入堆栈 2.遇到 + 运算符，因此弹出 4 和 3 ( 4 为栈顶元素，3 为次栈顶元素)，计算出 3+4</span></span><br><span class="line"><span class="comment">	 * 的值，得 7，再将 7 入栈 3.将 5 入栈 4.接下来是 * 运算符，因此弹出 5 和 7 ，计算出 7*5=35 ， 将 35 入栈 5.将</span></span><br><span class="line"><span class="comment">	 * 6 入栈 6.最后是 - 运算符，计算出 35-6 的值， 即 29 ，由此得出最终结果</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(List&lt;String&gt; ls)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建一个栈</span></span><br><span class="line">		Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line">		<span class="comment">// 遍历 ls</span></span><br><span class="line">		<span class="keyword">for</span> (String item : ls) &#123;</span><br><span class="line">			<span class="comment">// 这里用正则表达式来取出数</span></span><br><span class="line">			<span class="keyword">if</span> (item.matches(<span class="string">"\\d+"</span>)) &#123;<span class="comment">// 匹配的是多位数</span></span><br><span class="line">				<span class="comment">// 入栈</span></span><br><span class="line">				stack.push(item);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// pop出两个数，并运算，在入栈</span></span><br><span class="line">				<span class="keyword">int</span> num2 = Integer.parseInt(stack.pop());</span><br><span class="line">				<span class="keyword">int</span> num1 = Integer.parseInt(stack.pop());</span><br><span class="line">				<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (item.equals(<span class="string">"+"</span>)) &#123;</span><br><span class="line">					res = num1 + num2;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">					res = num1 - num2;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"*"</span>)) &#123;</span><br><span class="line">					res = num1 * num2;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"/"</span>)) &#123;</span><br><span class="line">					res = num1 / num2;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"运算符有误"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 把 res 入栈 (这里注意要把res转换成字符串，否则无法入栈)</span></span><br><span class="line">				stack.push(Integer.toString(res));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 最后留在stack中的数据是运算结果</span></span><br><span class="line">		<span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写一个类Operation 可以返回一个运算符对应的优先级</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ADD = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> SUB = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MUL = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DIV = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 写一个方法，返回对应的优先级数字</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(String operation)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">switch</span> (operation.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">			result = ADD;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">			result = SUB;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">			result = MUL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">			result = DIV;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			System.out.println(<span class="string">"不存在该运算符"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="18-递归的调用机制-打印-amp-阶乘"><a href="#18-递归的调用机制-打印-amp-阶乘" class="headerlink" title="18.递归的调用机制(打印&amp;阶乘)"></a>18.递归的调用机制(打印&amp;阶乘)</h3><p><img alt="image-20201" data-src="https://pic.downk.cc/item/5e6735ad98271cb2b893f6ba.png" class="lazyload"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  递归需要遵守的重要规则</span></span><br><span class="line"><span class="comment">  	1.执行一个方法时，就创建一个新的受保护的独立空间(栈空间)</span></span><br><span class="line"><span class="comment">  	2.方法的局部变量是独立的，不会互相影响，比如n变量</span></span><br><span class="line"><span class="comment">  	3.如果方法中使用的是引用类型变量(比如数组),就会共享引用类型数据</span></span><br><span class="line"><span class="comment">  	4.递归必须向退出递归的条件逼近，否则即使无限递归了，出现StackOverflowError</span></span><br><span class="line"><span class="comment">  	5.当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用就将结果返回给谁，</span></span><br><span class="line"><span class="comment">  	同时当方法执行完毕或者返回时，该方法也就执行完毕</span></span><br><span class="line"><span class="comment">  	</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursionTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		test(<span class="number">4</span>);</span><br><span class="line">		System.out.println(factorial(<span class="number">3</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印问题</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (n &gt; <span class="number">2</span>) &#123;</span><br><span class="line">			test(n - <span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"n="</span> + n);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 阶乘问题</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> factorial(n - <span class="number">1</span>) * n;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="19-递归-迷宫问题"><a href="#19-递归-迷宫问题" class="headerlink" title="19.递归-迷宫问题"></a>19.递归-迷宫问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用递归回溯来给小球找路</span></span><br><span class="line"><span class="comment"> * 说明</span></span><br><span class="line"><span class="comment"> * 1.map表示地图</span></span><br><span class="line"><span class="comment"> * 2.i j 表示从地图的哪个位置开始出发(1,1)</span></span><br><span class="line"><span class="comment"> * 3.如果小球能到map[6][5]位置，则说明通路找到</span></span><br><span class="line"><span class="comment"> * 4.约定：当map[i][j]为0表示该点没有走过 当为1表示墙；2表示通路可以走；3表示该点已经走过，但是走不通</span></span><br><span class="line"><span class="comment"> * 5.在走迷宫时，需要确定一下策略(方法) 下 -&gt; 右 -&gt; 上 -&gt; 左</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiGong</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 先创建一个二维数组，模拟迷宫</span></span><br><span class="line">		<span class="comment">// 地图</span></span><br><span class="line">		<span class="keyword">int</span>[][] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">		<span class="comment">// 使用 1 来表示墙</span></span><br><span class="line">		<span class="comment">// 上下全部置 1</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">			map[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">			map[<span class="number">7</span>][i] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">			map[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">			map[i][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 设置路障</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">			map[<span class="number">3</span>][i] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 开始走迷宫,并输入是否走到了终点</span></span><br><span class="line">		System.out.println(<span class="string">"是否走到了终点:"</span> + setWay(map, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 小球走过，并标识过的地图</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">				System.out.printf(<span class="string">"%d "</span>, map[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> map 	表示地图</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> i 	从哪个位置开始走</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 		如果找到通路就返回true ，否则返回false</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">setWay</span><span class="params">(<span class="keyword">int</span>[][] map, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (map[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (map[i][j] == <span class="number">0</span>) &#123;<span class="comment">// 如果当前这个点还没有走过</span></span><br><span class="line">				<span class="comment">// 按照策略走： 下 -&gt; 右 -&gt; 上 -&gt; 左</span></span><br><span class="line">				map[i][j] = <span class="number">2</span>;<span class="comment">// 假定该点是可以走通的</span></span><br><span class="line">				<span class="keyword">if</span> (setWay(map, i + <span class="number">1</span>, j)) &#123;<span class="comment">// 向下走</span></span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i, j + <span class="number">1</span>)) &#123;<span class="comment">// 向右走</span></span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i - <span class="number">1</span>, j)) &#123;<span class="comment">// 向上走</span></span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i, j - <span class="number">1</span>)) &#123;<span class="comment">// 向左走</span></span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// 说明该点是走不通的，是死路</span></span><br><span class="line">					map[i][j] = <span class="number">3</span>;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果map[i][j]!=0 则可能是 1 2 3</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="20-八皇后问题"><a href="#20-八皇后问题" class="headerlink" title="20.八皇后问题"></a>20.八皇后问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	1.第一个皇后先放第一行第一列</span></span><br><span class="line"><span class="comment">	2.第二个皇后放在第二行第一列，然后判断是否ok，如果不ok，继续放在第二列、第三列、以此把所有列都放		完，找到一个合适的</span></span><br><span class="line"><span class="comment">	3.继续第三个皇后，还是第一列、第二列.....直到第八个皇后也能放在一个不冲突的位置，算是找到了一个正	确解</span></span><br><span class="line"><span class="comment">	4.当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解</span></span><br><span class="line"><span class="comment">	全部得到</span></span><br><span class="line"><span class="comment">	5.然后回头继续第一个皇后放第二列，后面继续循环执行1,2,3,4的步骤</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	说明：理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题. 	arr[8] = &#123;0 , 4, 7, 5, 2, 6, 1, 3&#125; //对应arr 下标 表示第几行，即第几个皇后，</span></span><br><span class="line"><span class="comment">	arr[i] = val 	, val 表示第i+1个皇后，放在第i+1行的第val+1列</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queen8</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义一个max表示有多少个皇后</span></span><br><span class="line">	<span class="keyword">int</span> max = <span class="number">8</span>;</span><br><span class="line">	<span class="comment">// 定义数组array，保存皇后放置位置的结果，比如arr=&#123;0,4,7,5,2,6,,1,3&#125;</span></span><br><span class="line">	<span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> judgeCount=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 测试一把是否正确</span></span><br><span class="line">		Queen8 queen8 = <span class="keyword">new</span> Queen8();</span><br><span class="line">		queen8.check(<span class="number">0</span>);</span><br><span class="line">		System.out.printf(<span class="string">"一共有%d种解法"</span>, count);</span><br><span class="line">		System.out.printf(<span class="string">"一共判断冲突的次数为%d次"</span>, judgeCount);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 编写一个方法，放置第n个皇后</span></span><br><span class="line">	<span class="comment">// 特别注意：check是每一次递归时进入到check中都有一套for循环，因此会有回溯</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (n == max) &#123;</span><br><span class="line">			print();</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 依次放入皇后，并判断是否冲突</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">			<span class="comment">// 先把当前这个皇后n，放到该行的第1列</span></span><br><span class="line">			array[n] = i;</span><br><span class="line">			<span class="comment">// 判断放置第n个皇后到i列时，是否冲突</span></span><br><span class="line">			<span class="keyword">if</span> (judge(n)) &#123;<span class="comment">// 不冲突</span></span><br><span class="line">				<span class="comment">// 接着放n+1个皇后，即开始递归</span></span><br><span class="line">				check(n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 如果冲突，就继续执行array[n]=1; 即将第n个皇后，放置在本行的后移一列的位置</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查看我们放置的第n个皇后，就去检测该皇后是否和前面已经摆放的皇后冲突</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> n表示第n个皇后</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		judgeCount++;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 1. array[i] == array[n] 表示判断第n个皇后是否和前面的n-1个皇后在同一列 </span></span><br><span class="line"><span class="comment">			 * 2. Math.abs(n -i) == Math.abs(array[n] - array[i]) 表示判断第n个皇后是否和第i皇后是否在同一斜线 </span></span><br><span class="line"><span class="comment">			 * n = 1 放置第2列 1 n=1 array[1]=1 Math.abs(1-0) == 1</span></span><br><span class="line"><span class="comment">			 * Math.abs(array[n]-array[i])=Math.abs(1-0)=1</span></span><br><span class="line"><span class="comment">			 * 3.判断是否在同一行，没有必要，n每次都在递增</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 写一个方法,可以将皇后摆放的位置输出</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		count++;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">			System.out.print(array[i] + <span class="string">" "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="21-冒泡排序"><a href="#21-冒泡排序" class="headerlink" title="21.冒泡排序"></a>21.冒泡排序</h3><p><strong>1.图示过程</strong></p>
<p><img alt="img" data-src="https://pic.downk.cc/item/5e673ad998271cb2b896ae70.jpg" class="lazyload"></p>
<p><strong>2.动画展示</strong></p>
<p><img alt="img" data-src="https://pic.downk.cc/item/5e673ad898271cb2b896ae68.gif" class="lazyload"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">冒泡排序解析：</span></span><br><span class="line"><span class="comment">	1.原理：比较两个相邻的元素，将值大的元素交换到右边</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	2.思路：依次比较相邻的两个数，将比较小的数放在前面，比较大的数放在后面。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">　　　　(1)第一次比较：首先比较第一和第二个数，将小数放在前面，将大数放在后面。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">　　　　(2)比较第2和第3个数，将小数 放在前面，大数放在后面。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">　　　　......</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">　　　　(3)如此继续，知道比较到最后的两个数，将小数放在前面，大数放在后面，重复步骤，直至全部排序完成</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">　　　　(4)在上面一趟比较完成后，最后一个数一定是数组中最大的一个数，所以在比较第二趟的时候，最后一个		数是不参加比较的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">　　　　(5)在第二趟比较完成后，倒数第二个数也一定是数组中倒数第二大数，所以在第三趟的比较中，最后两个		数是不参与比较的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">　　　　(6)依次类推，每一趟比较次数减少依次</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 冒泡排序，时间复杂度O(n^2)</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 测试一下冒泡排序的速度，给8w个数据，测试 创建要给8w个随机数的数组</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8000</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			arr[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">8000</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line">		SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">		String dateStr1 = simpleDateFormat.format(date1);</span><br><span class="line">		System.out.println(<span class="string">"排序前的时间是:"</span> + dateStr1);</span><br><span class="line"></span><br><span class="line">		bubbleSort(arr);</span><br><span class="line"></span><br><span class="line">		Date date2 = <span class="keyword">new</span> Date();</span><br><span class="line">		String dateStr2 = simpleDateFormat.format(date2);</span><br><span class="line">		System.out.println(<span class="string">"排序后的时间是:"</span> + dateStr2);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// // 输出排序过后的数组</span></span><br><span class="line">		<span class="comment">// for (int i = 0; i &lt; arr.length; i++) &#123;</span></span><br><span class="line">		<span class="comment">// System.out.printf("%d ", arr[i]);</span></span><br><span class="line">		<span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将冒泡排序封装成一个方法来测试</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = <span class="number">0</span>;<span class="comment">// 临时变量</span></span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">// 标识变量，表示是否进行过交换</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">				<span class="comment">// 如果前面的数比后面的数大，则交换</span></span><br><span class="line">				<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">					flag = <span class="keyword">true</span>;</span><br><span class="line">					temp = arr[j];</span><br><span class="line">					arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">					arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// System.out.printf("完成了第%d趟排序\n", i + 1);</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (flag == <span class="keyword">false</span>) &#123;<span class="comment">// 在本趟排序中，一次交换都没有发生过(说明排序已经完成)</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				flag = <span class="keyword">false</span>;<span class="comment">// 重置flag，进行下一次判断</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="22-选择排序"><a href="#22-选择排序" class="headerlink" title="22.选择排序"></a>22.选择排序</h3><p><strong>1.图示过程</strong></p>
<p><img alt="img" data-src="https://pic.downk.cc/item/5e67395e98271cb2b895dff4.jpg" class="lazyload"></p>
<p><strong>2.动画展示</strong></p>
<p><img alt="img" data-src="https://pic.downk.cc/item/5e67395e98271cb2b895dfe2.gif" class="lazyload"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	选择排序是选择一个位置进行排序，将有序元素排放在数组最左边。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	第一轮排序</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	选择数组的第一个位置上的元素开始与其他元素进行逐个比较，即index[0]与index[1]、index[2]、		index[3]、index[4]、index[5]、index[6]、index[7]、index[8]、index[9]比较，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	将最小的元素放在index[0]所在的位置上。（期间进项相互比较和复制）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	第二轮排序</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	选择数组的第二个位置上的元素开始与其他元素进行逐个比较，即index[1]与index[2]、index[3]、		index[4]、index[5]、index[6]、index[7]、index[8]、index[9]比较,</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	将最小的一个元素放在index[1]所在的位置上。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	第三轮排序</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	。。。。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	直到整个数组有序。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	选择排序要比冒泡排序所用的时间要短  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			arr[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">80000</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line">		SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">		String dateStr1 = simpleDateFormat.format(date1);</span><br><span class="line">		System.out.println(<span class="string">"排序前的时间是:"</span> + dateStr1);</span><br><span class="line"></span><br><span class="line">		selectSort(arr);</span><br><span class="line"></span><br><span class="line">		Date date2 = <span class="keyword">new</span> Date();</span><br><span class="line">		String dateStr2 = simpleDateFormat.format(date2);</span><br><span class="line">		System.out.println(<span class="string">"排序后的时间是:"</span> + dateStr2);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// // 输出排序过后的数组</span></span><br><span class="line">		<span class="comment">// for (int i = 0; i &lt; arr.length; i++) &#123;</span></span><br><span class="line">		<span class="comment">// System.out.printf("%d ", arr[i]);</span></span><br><span class="line">		<span class="comment">// &#125;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 选择排序</span></span><br><span class="line">	<span class="comment">// 时间复杂度：O(n^2)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 使用逐步推导的方式来，讲解选择排序 第一轮 原始数组： 101，34，119，1 第一轮排序：1,34，119,101</span></span><br><span class="line"><span class="comment">		 * 算法：先简单-&gt;后复杂，就是可以把一个简单的算法，拆分成简单的问题-&gt;逐步解决</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> minIndex = i;</span><br><span class="line">			<span class="keyword">int</span> min = arr[i];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (min &gt; arr[j]) &#123;<span class="comment">// 说明假定的最小值，并不是最小</span></span><br><span class="line">					min = arr[j];<span class="comment">// 重置min</span></span><br><span class="line">					minIndex = j;<span class="comment">// 重置minIndex</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 将最小值，放在arr[0]，即交换</span></span><br><span class="line">			<span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">				arr[minIndex] = arr[i];</span><br><span class="line">				arr[i] = min;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="23-插入排序"><a href="#23-插入排序" class="headerlink" title="23.插入排序"></a>23.插入排序</h3><p><strong>1.图示过程</strong></p>
<p><img alt="img" data-src="https://pic.downk.cc/item/5e67395e98271cb2b895e000.jpg" class="lazyload"></p>
<p><strong>2.动画展示</strong></p>
<p><img alt="7789414-d3e7769cd797534d" data-src="https://pic.downk.cc/item/5e67342998271cb2b8934f90.gif" class="lazyload"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">		首先来解释一下插入排序法的原理，它的原理是每插入一个数都要将它和之前的已经完成排序的序列进行		重新排序，也就是要找到新插入的数对应原序列中的位置。那么也就是说，每次插入一个数都要对原来排序好	  的那部分序列进行重新的排序，时间复杂度同样为O（n²）。 这种算法是稳定的排序方法。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	我们要做的从a[1]开始，至于为什么不是a[0]。a[0]之前没有与a[0]进行比较的元素。我们插入a[1]，这个	时候我们需要遍历a[1]和a[1]之前的所有元素进行比较。这个时候我们需要设置一个变量j，用来记录第一个 	比 a[1]元素小的那个元素的下标，也就是a[1]要插入的位置，这个时候跳出循环，并且每发现一个比a[1]大的		元素，就要令这个元素后移一位。依次类推的算法直到整个数组的最后一个。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	以a[4]为例，假设a[3](注意，这个地方，从a[0]到a[3]已经完成了排序)小于 a[4]，那么就j的值是 3那		么这个时候 a[4] 就应该放在 下标是3+1 = 4的位置处</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			arr[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">80000</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line">		SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">		String dateStr1 = simpleDateFormat.format(date1);</span><br><span class="line">		System.out.println(<span class="string">"排序前的时间是:"</span> + dateStr1);</span><br><span class="line"></span><br><span class="line">		insertSort(arr);</span><br><span class="line"></span><br><span class="line">		Date date2 = <span class="keyword">new</span> Date();</span><br><span class="line">		String dateStr2 = simpleDateFormat.format(date2);</span><br><span class="line">		System.out.println(<span class="string">"排序后的时间是:"</span> + dateStr2);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 插入排序</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 使用逐步推导的方式来讲解，便于理解</span></span><br><span class="line">		<span class="comment">// 使用for循环来让代码简化</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> insertVal = arr[i];<span class="comment">// 定义待插入的数</span></span><br><span class="line">			<span class="keyword">int</span> insertIndex = i - <span class="number">1</span>;<span class="comment">// 即arr[i]的前面这个数的下标</span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 给insertVal 找到插入的位置 说明 1.insertVal &gt;=0保证在给insertVal找插入位置不越界</span></span><br><span class="line"><span class="comment">			 * 2.insertVal &lt; arr[insertIndex] 待插入的数还没有找到插入位置</span></span><br><span class="line"><span class="comment">			 * 3.就需要将arr[insertIndex]后移</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">while</span> (insertIndex &gt;= <span class="number">0</span> &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span><br><span class="line">				arr[insertIndex + <span class="number">1</span>] = arr[insertIndex];</span><br><span class="line">				insertIndex--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 当退出while循环时，说明插入的位置找到，insertIndex+1</span></span><br><span class="line">			<span class="comment">// 这里判断我们是否需要赋值</span></span><br><span class="line">			<span class="keyword">if</span> ((insertIndex + <span class="number">1</span>) != i) &#123;</span><br><span class="line">				arr[insertIndex + <span class="number">1</span>] = insertVal;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="24-希尔排序-交换法"><a href="#24-希尔排序-交换法" class="headerlink" title="24.希尔排序(交换法)"></a>24.希尔排序(交换法)</h3><blockquote>
<p><strong>希尔</strong>排序法介绍</p>
<p>希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种<strong>插入排序</strong>，它是简单插入排序经过改进之后的一个<strong>更高效的版本</strong>，也称为缩小增量排序。</p>
<p><strong>希尔排序法基本思想</strong></p>
<p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止</p>
<p>1)希尔排序时， 对有序序列在插入时采用<strong>交换</strong>法, 并测试排序速度.</p>
<p>2)希尔排序时， 对有序序列在插入时<strong>采用移动</strong>法, 并测试排序速度</p>
</blockquote>
<p><img alt="image-20200201135732431" data-src="https://pic.downk.cc/item/5e6735ad98271cb2b893f6c3.png" class="lazyload"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			arr[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">80000</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line">		SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">		String dateStr1 = simpleDateFormat.format(date1);</span><br><span class="line">		System.out.println(<span class="string">"排序前的时间是:"</span> + dateStr1);</span><br><span class="line"></span><br><span class="line">		shellSort(arr);</span><br><span class="line"></span><br><span class="line">		Date date2 = <span class="keyword">new</span> Date();</span><br><span class="line">		String dateStr2 = simpleDateFormat.format(date2);</span><br><span class="line">		System.out.println(<span class="string">"排序后的时间是:"</span> + dateStr2);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 希尔排序时，对有序序列在插入时采用交换法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 根据前面的逐步分析，使用循环处理</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="comment">// 遍历各组中所有的元素(共gap组，每组有2个元素)，步长gap</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = i - gap; j &gt;= <span class="number">0</span>; j -= gap) &#123;</span><br><span class="line">					<span class="comment">// 如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line">					<span class="keyword">if</span> (arr[j] &gt; arr[j + gap]) &#123;</span><br><span class="line">						temp = arr[j];</span><br><span class="line">						arr[j] = arr[j + gap];</span><br><span class="line">						arr[j + gap] = temp;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="25-希尔排序-移位法"><a href="#25-希尔排序-移位法" class="headerlink" title="25.希尔排序(移位法)"></a>25.希尔排序(移位法)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			arr[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">80000</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line">		SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">		String dateStr1 = simpleDateFormat.format(date1);</span><br><span class="line">		System.out.println(<span class="string">"排序前的时间是:"</span> + dateStr1);</span><br><span class="line"></span><br><span class="line">		shellSort(arr);</span><br><span class="line"></span><br><span class="line">		Date date2 = <span class="keyword">new</span> Date();</span><br><span class="line">		String dateStr2 = simpleDateFormat.format(date2);</span><br><span class="line">		System.out.println(<span class="string">"排序后的时间是:"</span> + dateStr2);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对交换式的希尔排序进行优化 -&gt; 移位法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 增量gap，并逐步的缩小增量</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="comment">// 从第gap个元素，逐个对其所在的组进行插入排序</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">				<span class="keyword">int</span> j = i;</span><br><span class="line">				<span class="keyword">int</span> temp = arr[j];</span><br><span class="line">				<span class="keyword">if</span> (arr[i] &lt; arr[j - gap]) &#123;</span><br><span class="line">					<span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; temp &lt; arr[j - gap]) &#123;</span><br><span class="line">						<span class="comment">// 移动</span></span><br><span class="line">						arr[j] = arr[j - gap];</span><br><span class="line">						j -= gap;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// 当退出while后，就给temp找到插入位置</span></span><br><span class="line">					arr[j] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="26-快速排序"><a href="#26-快速排序" class="headerlink" title="26.快速排序"></a>26.快速排序</h3><p><strong>1.总体流程</strong></p>
<p><img alt="img" data-src="https://pic.downk.cc/item/5e67395e98271cb2b895dfde.jpg" class="lazyload"></p>
<p><strong>2.动画展示</strong></p>
<p><img alt="img" data-src="https://pic.downk.cc/item/5e67395e98271cb2b895dfe5.gif" class="lazyload"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	快速排序(QuickSort)是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序郭晨可以递归进行，以此达到整个数据变成有序序列。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	1.从数列中挑出一个元素，称为 “基准”（pivot）;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3.递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			arr[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">80000</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line">		SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">		String dateStr1 = simpleDateFormat.format(date1);</span><br><span class="line">		System.out.println(<span class="string">"排序前的时间是:"</span> + dateStr1);</span><br><span class="line"></span><br><span class="line">		quickSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		Date date2 = <span class="keyword">new</span> Date();</span><br><span class="line">		String dateStr2 = simpleDateFormat.format(date2);</span><br><span class="line">		System.out.println(<span class="string">"排序后的时间是:"</span> + dateStr2);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> l = left; <span class="comment">//左下标</span></span><br><span class="line">		<span class="keyword">int</span> r = right; <span class="comment">//右下标</span></span><br><span class="line">		<span class="comment">//pivot 中轴值</span></span><br><span class="line">		<span class="keyword">int</span> pivot = arr[(left + right) / <span class="number">2</span>];</span><br><span class="line">		<span class="keyword">int</span> temp = <span class="number">0</span>; <span class="comment">//临时变量，作为交换时使用</span></span><br><span class="line">		<span class="comment">//while循环的目的是让比pivot 值小放到左边</span></span><br><span class="line">		<span class="comment">//比pivot 值大放到右边</span></span><br><span class="line">		<span class="keyword">while</span>( l &lt; r) &#123; </span><br><span class="line">			<span class="comment">//在pivot的左边一直找,找到大于等于pivot值,才退出</span></span><br><span class="line">			<span class="keyword">while</span>( arr[l] &lt; pivot) &#123;</span><br><span class="line">				l += <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//在pivot的右边一直找,找到小于等于pivot值,才退出</span></span><br><span class="line">			<span class="keyword">while</span>(arr[r] &gt; pivot) &#123;</span><br><span class="line">				r -= <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//如果l &gt;= r说明pivot 的左右两的值，已经按照左边全部是</span></span><br><span class="line">			<span class="comment">//小于等于pivot值，右边全部是大于等于pivot值</span></span><br><span class="line">			<span class="keyword">if</span>( l &gt;= r) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//交换</span></span><br><span class="line">			temp = arr[l];</span><br><span class="line">			arr[l] = arr[r];</span><br><span class="line">			arr[r] = temp;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//如果交换完后，发现这个arr[l] == pivot值 相等 r--， 前移</span></span><br><span class="line">			<span class="keyword">if</span>(arr[l] == pivot) &#123;</span><br><span class="line">				r -= <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//如果交换完后，发现这个arr[r] == pivot值 相等 l++， 后移</span></span><br><span class="line">			<span class="keyword">if</span>(arr[r] == pivot) &#123;</span><br><span class="line">				l += <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 如果 l == r, 必须l++, r--, 否则为出现栈溢出</span></span><br><span class="line">		<span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">			l += <span class="number">1</span>;</span><br><span class="line">			r -= <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//向左递归</span></span><br><span class="line">		<span class="keyword">if</span>(left &lt; r) &#123;</span><br><span class="line">			quickSort(arr, left, r);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//向右递归</span></span><br><span class="line">		<span class="keyword">if</span>(right &gt; l) &#123;</span><br><span class="line">			quickSort(arr, l, right);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="27-归并排序"><a href="#27-归并排序" class="headerlink" title="27.归并排序"></a>27.归并排序</h3><p><strong>1.归并排序流程</strong></p>
<p><img alt="img" data-src="https://pic.downk.cc/item/5e67382e98271cb2b89514ee.jpg" class="lazyload"></p>
<p><strong>2.合并两个有序数组的流程</strong></p>
<p><img alt="img" data-src="https://pic.downk.cc/item/5e67382e98271cb2b8951502.jpg" class="lazyload"></p>
<p><strong>3.动画展示</strong></p>
<p><img alt="img" data-src="https://pic.downk.cc/item/5e67382e98271cb2b8951510.gif" class="lazyload"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergetSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8000000</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			arr[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">8000000</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"排序前"</span>);</span><br><span class="line">		Date data1 = <span class="keyword">new</span> Date();</span><br><span class="line">		SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">		String date1Str = simpleDateFormat.format(data1);</span><br><span class="line">		System.out.println(<span class="string">"排序前的时间是="</span> + date1Str);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> temp[] = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length]; <span class="comment">// 归并排序需要一个额外空间</span></span><br><span class="line">		mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, temp);</span><br><span class="line"></span><br><span class="line">		Date data2 = <span class="keyword">new</span> Date();</span><br><span class="line">		String date2Str = simpleDateFormat.format(data2);</span><br><span class="line">		System.out.println(<span class="string">"排序前的时间是="</span> + date2Str);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分+合方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">			<span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>; <span class="comment">// 中间索引</span></span><br><span class="line">			<span class="comment">// 向左递归进行分解</span></span><br><span class="line">			mergeSort(arr, left, mid, temp);</span><br><span class="line">			<span class="comment">// 向右递归进行分解</span></span><br><span class="line">			mergeSort(arr, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">			<span class="comment">// 合并</span></span><br><span class="line">			merge(arr, left, mid, right, temp);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 合并的方法</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">	 *            排序的原始数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">	 *            左边有序序列的初始索引</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> mid</span></span><br><span class="line"><span class="comment">	 *            中间索引</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">	 *            右边索引</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> temp</span></span><br><span class="line"><span class="comment">	 *            做中转的数组</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> i = left; <span class="comment">// 初始化i, 左边有序序列的初始索引</span></span><br><span class="line">		<span class="keyword">int</span> j = mid + <span class="number">1</span>; <span class="comment">// 初始化j, 右边有序序列的初始索引</span></span><br><span class="line">		<span class="keyword">int</span> t = <span class="number">0</span>; <span class="comment">// 指向temp数组的当前索引</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// (一)</span></span><br><span class="line">		<span class="comment">// 先把左右两边(有序)的数据按照规则填充到temp数组</span></span><br><span class="line">		<span class="comment">// 直到左右两边的有序序列，有一边处理完毕为止</span></span><br><span class="line">		<span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;<span class="comment">// 继续</span></span><br><span class="line">			<span class="comment">// 如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素</span></span><br><span class="line">			<span class="comment">// 即将左边的当前元素，填充到 temp数组</span></span><br><span class="line">			<span class="comment">// 然后 t++, i++</span></span><br><span class="line">			<span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">				temp[t] = arr[i];</span><br><span class="line">				t += <span class="number">1</span>;</span><br><span class="line">				i += <span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">// 反之,将右边有序序列的当前元素，填充到temp数组</span></span><br><span class="line">				temp[t] = arr[j];</span><br><span class="line">				t += <span class="number">1</span>;</span><br><span class="line">				j += <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// (二)</span></span><br><span class="line">		<span class="comment">// 把有剩余数据的一边的数据依次全部填充到temp</span></span><br><span class="line">		<span class="keyword">while</span> (i &lt;= mid) &#123; <span class="comment">// 左边的有序序列还有剩余的元素，就全部填充到temp</span></span><br><span class="line">			temp[t] = arr[i];</span><br><span class="line">			t += <span class="number">1</span>;</span><br><span class="line">			i += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (j &lt;= right) &#123; <span class="comment">// 右边的有序序列还有剩余的元素，就全部填充到temp</span></span><br><span class="line">			temp[t] = arr[j];</span><br><span class="line">			t += <span class="number">1</span>;</span><br><span class="line">			j += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// (三)</span></span><br><span class="line">		<span class="comment">// 将temp数组的元素拷贝到arr</span></span><br><span class="line">		<span class="comment">// 注意，并不是每次都拷贝所有</span></span><br><span class="line">		t = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> tempLeft = left; <span class="comment">//</span></span><br><span class="line">		<span class="comment">// 第一次合并 tempLeft = 0 , right = 1 // tempLeft = 2 right = 3 // tL=0 ri=3</span></span><br><span class="line">		<span class="comment">// 最后一次 tempLeft = 0 right = 7</span></span><br><span class="line">		<span class="keyword">while</span> (tempLeft &lt;= right) &#123;</span><br><span class="line">			arr[tempLeft] = temp[t];</span><br><span class="line">			t += <span class="number">1</span>;</span><br><span class="line">			tempLeft += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="28-基数排序"><a href="#28-基数排序" class="headerlink" title="28.基数排序"></a>28.基数排序</h3><blockquote>
<p>相比其它排序，主要是利用比较和交换，而基数排序则是利用分配和收集两种基本操作。基数 排序是一种按记录关键字的各位值逐步进行排序的方法。此种排序一般适用于记录的关键字为整数类型的情况。所有对于字符串和文字排序不适合。</p>
<p>  实现：将所有待比较数值（自然数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p>
<p>  基数排序的两种方式：</p>
<ol>
<li><p>高位优先，又称为最有效键(MSD),它的比较方向是由右至左；</p>
</li>
<li><p>低位优先，又称为最无效键(LSD),它的比较方向是由左至右；</p>
</li>
</ol>
</blockquote>
<p><strong>1.图解</strong>    </p>
<p><img alt="基数排序实例1" data-src="https://pic.downk.cc/item/5e67342998271cb2b8934f8a.png" class="lazyload"></p>
<p><strong>2.动画展示</strong></p>
<p><img alt="堆排序动画演示" data-src="https://pic.downk.cc/item/5e67342998271cb2b8934f8d.gif" class="lazyload"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123; <span class="number">63</span>, <span class="number">157</span>, <span class="number">189</span>, <span class="number">51</span>, <span class="number">101</span>, <span class="number">47</span>, <span class="number">141</span>, <span class="number">121</span>, <span class="number">157</span>, <span class="number">156</span>, <span class="number">194</span>, <span class="number">117</span>,<span class="number">98</span>, <span class="number">139</span>, <span class="number">67</span>, <span class="number">133</span>, <span class="number">181</span>, <span class="number">12</span>, <span class="number">28</span>, <span class="number">0</span>, <span class="number">109</span> &#125;;</span><br><span class="line"></span><br><span class="line">		radixSort(arr);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">			System.out.printf(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 高位优先法</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">	 *            待排序列，必须为自然数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 待排序列最大值</span></span><br><span class="line">		<span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">int</span> exp;<span class="comment">// 指数</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 计算最大值</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> anArr : arr) &#123;</span><br><span class="line">			<span class="keyword">if</span> (anArr &gt; max) &#123;</span><br><span class="line">				max = anArr;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 从个位开始，对数组进行排序</span></span><br><span class="line">		<span class="keyword">for</span> (exp = <span class="number">1</span>; max / exp &gt; <span class="number">0</span>; exp *= <span class="number">10</span>) &#123;</span><br><span class="line">			<span class="comment">// 存储待排元素的临时数组</span></span><br><span class="line">			<span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">			<span class="comment">// 分桶个数</span></span><br><span class="line">			<span class="keyword">int</span>[] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 将数据出现的次数存储在buckets中</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">				<span class="comment">// (value / exp) % 10 :value的最底位(个位)</span></span><br><span class="line">				buckets[(value / exp) % <span class="number">10</span>]++;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 更改buckets[i]，</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">				buckets[i] += buckets[i - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 将数据存储到临时数组temp中</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">				temp[buckets[(arr[i] / exp) % <span class="number">10</span>] - <span class="number">1</span>] = arr[i];</span><br><span class="line">				buckets[(arr[i] / exp) % <span class="number">10</span>]--;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 将有序元素temp赋给arr</span></span><br><span class="line">			System.arraycopy(temp, <span class="number">0</span>, arr, <span class="number">0</span>, arr.length);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="29-线性查找"><a href="#29-线性查找" class="headerlink" title="29.线性查找"></a>29.线性查找</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeqSearch</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">9</span>,<span class="number">11</span>,-<span class="number">1</span>,<span class="number">34</span>,<span class="number">89</span>&#125;;</span><br><span class="line">		<span class="keyword">int</span> index = seqSearch(arr,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(index == -<span class="number">1</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">"没找到"</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"找到了，下标为:"</span>+index);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> 	<span class="keyword">int</span> <span class="title">seqSearch</span><span class="params">(<span class="keyword">int</span> [] arr,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">		<span class="comment">//线性查找是逐一比对，发现有相同的值，就返回下标</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[i]==value)&#123;</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="30-二分查找"><a href="#30-二分查找" class="headerlink" title="30.二分查找"></a>30.二分查找</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 二分查找的思路分析</span></span><br><span class="line"><span class="comment">1. 首先确定该数组的中间的下标</span></span><br><span class="line"><span class="comment">mid = (left + right) / 2</span></span><br><span class="line"><span class="comment">2. 然后让需要查找的数 findVal 和 arr[mid] 比较</span></span><br><span class="line"><span class="comment">2. 1 findVal &gt; arr[mid] ,  说明你要查找的数在mid 的右边, 因此需要递归的向右查找</span></span><br><span class="line"><span class="comment">2.2 findVal &lt; arr[mid], 说明你要查找的数在mid 的左边, 因此需要递归的向左查找</span></span><br><span class="line"><span class="comment">2.3  findVal == arr[mid] 说明找到，就返回</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//什么时候我们需要结束递归.</span></span><br><span class="line"><span class="comment">1) 找到就结束递归 </span></span><br><span class="line"><span class="comment">2) 递归完整个数组，仍然没有找到findVal ，也需要结束递归  当 left &gt; right 就需要退出</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：使用二分查找的前提是 该数组是有序的.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//int arr[] = &#123; 1, 8, 10, 89,1000,1000, 1234 &#125;;</span></span><br><span class="line">		<span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> , <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span> &#125;;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line"><span class="comment">//		int resIndex = binarySearch(arr, 0, arr.length - 1, 1000);</span></span><br><span class="line"><span class="comment">//		System.out.println("resIndex=" + resIndex);</span></span><br><span class="line">		</span><br><span class="line">		List&lt;Integer&gt; resIndexList = binarySearch2(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">		System.out.println(<span class="string">"resIndexList="</span> + resIndexList);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 二分查找算法</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">	 *            数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">	 *            左边的索引</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">	 *            右边的索引</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> findVal</span></span><br><span class="line"><span class="comment">	 *            要查找的值</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 如果找到就返回下标，如果没有找到，就返回 -1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> findVal)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 当 left &gt; right 时，说明递归整个数组，但是没有找到</span></span><br><span class="line">		<span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (findVal &gt; midVal) &#123; <span class="comment">// 向 右递归</span></span><br><span class="line">			<span class="keyword">return</span> binarySearch(arr, mid + <span class="number">1</span>, right, findVal);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; midVal) &#123; <span class="comment">// 向左递归</span></span><br><span class="line">			<span class="keyword">return</span> binarySearch(arr, left, mid - <span class="number">1</span>, findVal);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//完成一个课后思考题:</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 课后思考题： &#123;1,8, 10, 89, 1000, 1000，1234&#125; 当一个有序数组中，</span></span><br><span class="line"><span class="comment">	 * 有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 思路分析</span></span><br><span class="line"><span class="comment">	 * 1. 在找到mid 索引值，不要马上返回</span></span><br><span class="line"><span class="comment">	 * 2. 向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span></span><br><span class="line"><span class="comment">	 * 3. 向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span></span><br><span class="line"><span class="comment">	 * 4. 将Arraylist返回</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">binarySearch2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> findVal)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"hello~"</span>);</span><br><span class="line">		<span class="comment">// 当 left &gt; right 时，说明递归整个数组，但是没有找到</span></span><br><span class="line">		<span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (findVal &gt; midVal) &#123; <span class="comment">// 向 右递归</span></span><br><span class="line">			<span class="keyword">return</span> binarySearch2(arr, mid + <span class="number">1</span>, right, findVal);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; midVal) &#123; <span class="comment">// 向左递归</span></span><br><span class="line">			<span class="keyword">return</span> binarySearch2(arr, left, mid - <span class="number">1</span>, findVal);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//			 * 思路分析</span></span><br><span class="line"><span class="comment">//			 * 1. 在找到mid 索引值，不要马上返回</span></span><br><span class="line"><span class="comment">//			 * 2. 向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span></span><br><span class="line"><span class="comment">//			 * 3. 向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span></span><br><span class="line"><span class="comment">//			 * 4. 将Arraylist返回</span></span><br><span class="line">			</span><br><span class="line">			List&lt;Integer&gt; resIndexlist = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">			<span class="comment">//向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span></span><br><span class="line">			<span class="keyword">int</span> temp = mid - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (temp &lt; <span class="number">0</span> || arr[temp] != findVal) &#123;<span class="comment">//退出</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//否则，就temp 放入到 resIndexlist</span></span><br><span class="line">				resIndexlist.add(temp);</span><br><span class="line">				temp -= <span class="number">1</span>; <span class="comment">//temp左移</span></span><br><span class="line">			&#125;</span><br><span class="line">			resIndexlist.add(mid);  <span class="comment">//</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">//向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span></span><br><span class="line">			temp = mid + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (temp &gt; arr.length - <span class="number">1</span> || arr[temp] != findVal) &#123;<span class="comment">//退出</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//否则，就temp 放入到 resIndexlist</span></span><br><span class="line">				resIndexlist.add(temp);</span><br><span class="line">				temp += <span class="number">1</span>; <span class="comment">//temp右移</span></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span> resIndexlist;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="31-差值查找"><a href="#31-差值查找" class="headerlink" title="31.差值查找"></a>31.差值查找</h3><blockquote>
<p><strong>插值查找原理介绍**</strong>:**</p>
<p>1)插值查找算法类似于二分查找，不同的是插值查找每次从<strong>自适应**</strong>mid**处开始查找。</p>
<p>2)将折半查找中的求mid 索引的公式 , low 表示左边索引left, high表示右边索引right.<br>key 就是前面我们讲的 findVal</p>
<p><img alt="image-20200203144620746" data-src="https://pic.downk.cc/item/5e67342998271cb2b8934f9e.png" class="lazyload"></p>
<p>3)int mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low]) ;/<em>插值索引</em>/<br>对应前面的代码公式：<br>int mid = left + (right – left) * (findVal – arr[left]) / (arr[right] – arr[left])</p>
<p>4)举例说明插值查找算法 1-100 的数组</p>
<p>差值查找注意事项：</p>
<p>1.对于数量较大，关键字分布比较均匀的查找表来说，采用插值查找速度较快</p>
<p>2.关键字分布不均匀的情况下，该方法不一定比折半查找要好</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertValueSearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line"><span class="comment">//		int [] arr = new int[100];</span></span><br><span class="line"><span class="comment">//		for(int i = 0; i &lt; 100; i++) &#123;</span></span><br><span class="line"><span class="comment">//			arr[i] = i + 1;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>,<span class="number">1000</span>,<span class="number">1000</span>, <span class="number">1234</span> &#125;;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> index = insertValueSearch(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="number">1234</span>);</span><br><span class="line">		<span class="comment">//int index = binarySearch(arr, 0, arr.length, 1);</span></span><br><span class="line">		System.out.println(<span class="string">"index = "</span> + index);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> findVal)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"二分查找被调用~"</span>);</span><br><span class="line">		<span class="comment">// 当 left &gt; right 时，说明递归整个数组，但是没有找到</span></span><br><span class="line">		<span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (findVal &gt; midVal) &#123; <span class="comment">// 向 右递归</span></span><br><span class="line">			<span class="keyword">return</span> binarySearch(arr, mid + <span class="number">1</span>, right, findVal);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; midVal) &#123; <span class="comment">// 向左递归</span></span><br><span class="line">			<span class="keyword">return</span> binarySearch(arr, left, mid - <span class="number">1</span>, findVal);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//编写插值查找算法</span></span><br><span class="line">	<span class="comment">//说明：插值查找算法，也要求数组是有序的</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> left 左边索引</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> right 右边索引</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> findVal 查找值</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 如果找到，就返回对应的下标，如果没有找到，返回-1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">insertValueSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> findVal)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"插值查找次数~~"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//注意：findVal &lt; arr[0]  和  findVal &gt; arr[arr.length - 1] 必须需要</span></span><br><span class="line">		<span class="comment">//否则我们得到的 mid 可能越界</span></span><br><span class="line">		<span class="keyword">if</span> (left &gt; right || findVal &lt; arr[<span class="number">0</span>] || findVal &gt; arr[arr.length - <span class="number">1</span>]) &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 求出mid, 自适应</span></span><br><span class="line">		<span class="keyword">int</span> mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);</span><br><span class="line">		<span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line">		<span class="keyword">if</span> (findVal &gt; midVal) &#123; <span class="comment">// 说明应该向右边递归</span></span><br><span class="line">			<span class="keyword">return</span> insertValueSearch(arr, mid + <span class="number">1</span>, right, findVal);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; midVal) &#123; <span class="comment">// 说明向左递归查找</span></span><br><span class="line">			<span class="keyword">return</span> insertValueSearch(arr, left, mid - <span class="number">1</span>, findVal);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="32-斐波那契查找"><a href="#32-斐波那契查找" class="headerlink" title="32.斐波那契查找"></a>32.斐波那契查找</h3><blockquote>
<p>l斐波那契(黄金分割法)查找算法</p>
<p>斐波那契(黄金分割法)原理:</p>
<p>斐波那契查找原理与前两种相似，仅仅<br>改变了中间结点（mid）的位置，mid不<br>再是中间或插值得到，而是位于黄金分<br>割点附近，即mid=low+F(k-1)-1<br>（F代表斐波那契数列），如下图所示</p>
<p><img alt="image-20200203163404587" data-src="https://pic.downk.cc/item/5e6735ad98271cb2b893f6b6.png" class="lazyload"></p>
<p>对F(k-1)-1的理解：</p>
<p>1)由斐波那契数列 F[k]=F[k-1]+F[k-2] 的性质，可以得到 （F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1 。该式说明：只要顺序表的长度为F[k]-1，则可以将该表分成长度为F[k-1]-1和F[k-2]-1的两段，即如上图所示。从而中间位置为mid=low+F(k-1)-1      </p>
<p>2)类似的，每一子段也可以用相同的方式分割</p>
<p>3)但顺序表长度n不一定刚好等于F[k]-1，所以需要将原来的顺序表长度n增加至F[k]-1。这里的k值只要能使得F[k]-1恰好大于或等于n即可，由以下代码得到,顺序表长度增加后，新增的位置（从n+1到F[k]-1位置），都赋为n位置的值即可。</p>
<p>while(n&gt;fib(k)-1)</p>
<p> k++;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FibonacciSearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> maxSize = <span class="number">20</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> [] arr = &#123;<span class="number">1</span>,<span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>, <span class="number">1000</span>, <span class="number">1234</span>&#125;;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"index="</span> + fibSearch(arr, <span class="number">189</span>));<span class="comment">// 0</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//因为后面我们mid=low+F(k-1)-1，需要使用到斐波那契数列，因此我们需要先获取到一个斐波那契数列</span></span><br><span class="line">	<span class="comment">//非递归方法得到一个斐波那契数列</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] fib() &#123;</span><br><span class="line">		<span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">		f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxSize; i++) &#123;</span><br><span class="line">			f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> f;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//编写斐波那契查找算法</span></span><br><span class="line">	<span class="comment">//使用非递归的方式编写算法</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> a  数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> key 我们需要查找的关键码(值)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 返回对应的下标，如果没有-1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibSearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> high = a.length - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">//表示斐波那契分割数值的下标</span></span><br><span class="line">		<span class="keyword">int</span> mid = <span class="number">0</span>; <span class="comment">//存放mid值</span></span><br><span class="line">		<span class="keyword">int</span> f[] = fib(); <span class="comment">//获取到斐波那契数列</span></span><br><span class="line">		<span class="comment">//获取到斐波那契分割数值的下标</span></span><br><span class="line">		<span class="keyword">while</span>(high &gt; f[k] - <span class="number">1</span>) &#123;</span><br><span class="line">			k++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//因为 f[k] 值 可能大于 a 的 长度，因此我们需要使用Arrays类，构造一个新的数组，并指向temp[]</span></span><br><span class="line">		<span class="comment">//不足的部分会使用0填充</span></span><br><span class="line">		<span class="keyword">int</span>[] temp = Arrays.copyOf(a, f[k]);</span><br><span class="line">		<span class="comment">//实际上需求使用a数组最后的数填充 temp</span></span><br><span class="line">		<span class="comment">//举例:</span></span><br><span class="line">		<span class="comment">//temp = &#123;1,8, 10, 89, 1000, 1234, 0, 0&#125;  =&gt; &#123;1,8, 10, 89, 1000, 1234, 1234, 1234,&#125;</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = high + <span class="number">1</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">			temp[i] = a[high];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 使用while来循环处理，找到我们的数 key</span></span><br><span class="line">		<span class="keyword">while</span> (low &lt;= high) &#123; <span class="comment">// 只要这个条件满足，就可以找</span></span><br><span class="line">			mid = low + f[k - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(key &lt; temp[mid]) &#123; <span class="comment">//我们应该继续向数组的前面查找(左边)</span></span><br><span class="line">				high = mid - <span class="number">1</span>;</span><br><span class="line">				<span class="comment">//为甚是 k--</span></span><br><span class="line">				<span class="comment">//说明</span></span><br><span class="line">				<span class="comment">//1. 全部元素 = 前面的元素 + 后边元素</span></span><br><span class="line">				<span class="comment">//2. f[k] = f[k-1] + f[k-2]</span></span><br><span class="line">				<span class="comment">//因为 前面有 f[k-1]个元素,所以可以继续拆分 f[k-1] = f[k-2] + f[k-3]</span></span><br><span class="line">				<span class="comment">//即 在 f[k-1] 的前面继续查找 k--</span></span><br><span class="line">				<span class="comment">//即下次循环 mid = f[k-1-1]-1</span></span><br><span class="line">				k--;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( key &gt; temp[mid]) &#123; <span class="comment">// 我们应该继续向数组的后面查找(右边)</span></span><br><span class="line">				low = mid + <span class="number">1</span>;</span><br><span class="line">				<span class="comment">//为什么是k -=2</span></span><br><span class="line">				<span class="comment">//说明</span></span><br><span class="line">				<span class="comment">//1. 全部元素 = 前面的元素 + 后边元素</span></span><br><span class="line">				<span class="comment">//2. f[k] = f[k-1] + f[k-2]</span></span><br><span class="line">				<span class="comment">//3. 因为后面我们有f[k-2] 所以可以继续拆分 f[k-1] = f[k-3] + f[k-4]</span></span><br><span class="line">				<span class="comment">//4. 即在f[k-2] 的前面进行查找 k -=2</span></span><br><span class="line">				<span class="comment">//5. 即下次循环 mid = f[k - 1 - 2] - 1</span></span><br><span class="line">				k -= <span class="number">2</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">//找到</span></span><br><span class="line">				<span class="comment">//需要确定，返回的是哪个下标</span></span><br><span class="line">				<span class="keyword">if</span>(mid &lt;= high) &#123;</span><br><span class="line">					<span class="keyword">return</span> mid;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> high;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="33-哈希表"><a href="#33-哈希表" class="headerlink" title="33.哈希表"></a>33.哈希表</h3><blockquote>
<p>散列表（Hashtable，也叫哈希表），是根据关键码值(Keyvalue)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。 </p>
</blockquote>
<p><img alt="image-20200203201710561" data-src="https://pic.downk.cc/item/5e6736cc98271cb2b8946000.png" class="lazyload"></p>
<p><img alt="image-20200203201729273" data-src="https://pic.downk.cc/item/5e6736cc98271cb2b8945fee.png" class="lazyload"></p>
<blockquote>
<p>要求:</p>
<p>1)不使用数据库,,速度越快越好=&gt;哈希表(散列)</p>
<p>2)添加时，保证按照id从低到高插入[课后思考：如果id不是从低到高插入，但要求各条链表仍是从低到高，怎么解决?]</p>
<p>3)使用链表来实现哈希表,该链表不带表头[即:链表的第一个结点就存放雇员信息]4)思路分析并画出示意图 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTabDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//创建哈希表</span></span><br><span class="line">		HashTab hashTab = <span class="keyword">new</span> HashTab(<span class="number">7</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//写一个简单的菜单</span></span><br><span class="line">		<span class="keyword">int</span> key = <span class="number">0</span>;</span><br><span class="line">		Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"1.add:  添加雇员"</span>);</span><br><span class="line">			System.out.println(<span class="string">"2.list: 显示雇员"</span>);</span><br><span class="line">			System.out.println(<span class="string">"3.find: 查找雇员"</span>);</span><br><span class="line">			System.out.println(<span class="string">"4.exit: 退出系统"</span>);</span><br><span class="line">			</span><br><span class="line">			key = scanner.nextInt();</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">switch</span> (key) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">				System.out.println(<span class="string">"输入id"</span>);</span><br><span class="line">				<span class="keyword">int</span> id = scanner.nextInt();</span><br><span class="line">				System.out.println(<span class="string">"输入名字"</span>);</span><br><span class="line">				String name = scanner.next();</span><br><span class="line">				<span class="comment">//创建 雇员</span></span><br><span class="line">				Emp emp = <span class="keyword">new</span> Emp(id, name);</span><br><span class="line">				hashTab.add(emp);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">				hashTab.list();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">				System.out.println(<span class="string">"请输入要查找的id"</span>);</span><br><span class="line">				id = scanner.nextInt();</span><br><span class="line">				hashTab.findEmpById(id);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">				scanner.close();</span><br><span class="line">				System.exit(<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建HashTab 管理多条链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTab</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> EmpLinkedList[] empLinkedListArray;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> size; <span class="comment">//表示有多少条链表</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HashTab</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.size = size;</span><br><span class="line">		<span class="comment">//初始化empLinkedListArray</span></span><br><span class="line">		empLinkedListArray = <span class="keyword">new</span> EmpLinkedList[size];</span><br><span class="line">		<span class="comment">//？留一个坑, 这时不要分别初始化每个链表</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">			empLinkedListArray[i] = <span class="keyword">new</span> EmpLinkedList();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//添加雇员</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Emp emp)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//根据员工的id ,得到该员工应当添加到哪条链表</span></span><br><span class="line">		<span class="keyword">int</span> empLinkedListNO = hashFun(emp.id);</span><br><span class="line">		<span class="comment">//将emp 添加到对应的链表中</span></span><br><span class="line">		empLinkedListArray[empLinkedListNO].add(emp);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历所有的链表,遍历hashtab</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">			empLinkedListArray[i].list(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//根据输入的id,查找雇员</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findEmpById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//使用散列函数确定到哪条链表查找</span></span><br><span class="line">		<span class="keyword">int</span> empLinkedListNO = hashFun(id);</span><br><span class="line">		Emp emp = empLinkedListArray[empLinkedListNO].findEmpById(id);</span><br><span class="line">		<span class="keyword">if</span>(emp != <span class="keyword">null</span>) &#123;<span class="comment">//找到</span></span><br><span class="line">			System.out.printf(<span class="string">"在第%d条链表中找到 雇员 id = %d\n"</span>, (empLinkedListNO + <span class="number">1</span>), id);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"在哈希表中，没有找到该雇员~"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//编写散列函数, 使用一个简单取模法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashFun</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id % size;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表示一个雇员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emp</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="keyword">public</span> Emp next; <span class="comment">//next 默认为 null</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建EmpLinkedList ,表示链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmpLinkedList</span> </span>&#123;</span><br><span class="line">	<span class="comment">//头指针，执行第一个Emp,因此我们这个链表的head 是直接指向第一个Emp</span></span><br><span class="line">	<span class="keyword">private</span> Emp head; <span class="comment">//默认null</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//添加雇员到链表</span></span><br><span class="line">	<span class="comment">//说明</span></span><br><span class="line">	<span class="comment">//1. 假定，当添加雇员时，id 是自增长，即id的分配总是从小到大</span></span><br><span class="line">	<span class="comment">//   因此我们将该雇员直接加入到本链表的最后即可</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Emp emp)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//如果是添加第一个雇员</span></span><br><span class="line">		<span class="keyword">if</span>(head == <span class="keyword">null</span>) &#123;</span><br><span class="line">			head = emp;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果不是第一个雇员，则使用一个辅助的指针，帮助定位到最后</span></span><br><span class="line">		Emp curEmp = head;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(curEmp.next == <span class="keyword">null</span>) &#123;<span class="comment">//说明到链表最后</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			curEmp = curEmp.next; <span class="comment">//后移</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//退出时直接将emp 加入链表</span></span><br><span class="line">		curEmp.next = emp;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//遍历链表的雇员信息</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(head == <span class="keyword">null</span>) &#123; <span class="comment">//说明链表为空</span></span><br><span class="line">			System.out.println(<span class="string">"第 "</span>+(no+<span class="number">1</span>)+<span class="string">" 链表为空"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.print(<span class="string">"第 "</span>+(no+<span class="number">1</span>)+<span class="string">" 链表的信息为"</span>);</span><br><span class="line">		Emp curEmp = head; <span class="comment">//辅助指针</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			System.out.printf(<span class="string">" =&gt; id=%d name=%s\t"</span>, curEmp.id, curEmp.name);</span><br><span class="line">			<span class="keyword">if</span>(curEmp.next == <span class="keyword">null</span>) &#123;<span class="comment">//说明curEmp已经是最后结点</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			curEmp = curEmp.next; <span class="comment">//后移，遍历</span></span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//根据id查找雇员</span></span><br><span class="line">	<span class="comment">//如果查找到，就返回Emp, 如果没有找到，就返回null</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Emp <span class="title">findEmpById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//判断链表是否为空</span></span><br><span class="line">		<span class="keyword">if</span>(head == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//辅助指针</span></span><br><span class="line">		Emp curEmp = head;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(curEmp.id == id) &#123;<span class="comment">//找到</span></span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">//这时curEmp就指向要查找的雇员</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//退出</span></span><br><span class="line">			<span class="keyword">if</span>(curEmp.next == <span class="keyword">null</span>) &#123;<span class="comment">//说明遍历当前链表没有找到该雇员</span></span><br><span class="line">				curEmp = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			curEmp = curEmp.next;<span class="comment">//以后</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> curEmp;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="34-二叉树"><a href="#34-二叉树" class="headerlink" title="34.二叉树"></a>34.二叉树</h3><blockquote>
<p>二叉树的遍历说明：</p>
<p>前序遍历：先输出父节点，在遍历左子树和右子树</p>
<p>中序遍历：先遍历左子树，在输出父节点，在遍历右子树</p>
<p>后序遍历：先遍历左子树，在遍历右子树，最后输出父节点</p>
<p>小结：看输出父节点的顺序，就能够确定是前序，中序或者是后序</p>
<p>1.创建一个二叉树</p>
<p>2.前序遍历：</p>
<p>​    1-先输出当前节点(初始的时候是root节点)</p>
<p>​    2-如果左子节点不为空，则继续前序遍历</p>
<p>​    3-如果右子节点不为空，则继续前序遍历</p>
<p>3.中序遍历：</p>
<p>​    1-如果当前节点的左子节点不为空，则递归中序遍历，输出当前节点</p>
<p>​    2-如果当前节点的右子节点不为空，则递归中序遍历</p>
<p>4.后序遍历：</p>
<p>​    1-如果当前节点的左子节点不为空，则递归后序遍历</p>
<p>​    2-如果当前节点的右子节点不为空，则递归后序遍历，输出当前 节点</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//先需要创建一颗二叉树</span></span><br><span class="line">		BinaryTree binaryTree = <span class="keyword">new</span> BinaryTree();</span><br><span class="line">		<span class="comment">//创建需要的结点</span></span><br><span class="line">		HeroNode root = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">"宋江"</span>);</span><br><span class="line">		HeroNode node2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">"吴用"</span>);</span><br><span class="line">		HeroNode node3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">"卢俊义"</span>);</span><br><span class="line">		HeroNode node4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">"林冲"</span>);</span><br><span class="line">		HeroNode node5 = <span class="keyword">new</span> HeroNode(<span class="number">5</span>, <span class="string">"关胜"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树</span></span><br><span class="line">		root.setLeft(node2);</span><br><span class="line">		root.setRight(node3);</span><br><span class="line">		node3.setRight(node4);</span><br><span class="line">		node3.setLeft(node5);</span><br><span class="line">		binaryTree.setRoot(root);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//测试</span></span><br><span class="line"><span class="comment">//		System.out.println("前序遍历"); // 1,2,3,5,4</span></span><br><span class="line"><span class="comment">//		binaryTree.preOrder();</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//测试 </span></span><br><span class="line"><span class="comment">//		System.out.println("中序遍历");</span></span><br><span class="line"><span class="comment">//		binaryTree.infixOrder(); // 2,1,5,3,4</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//		System.out.println("后序遍历");</span></span><br><span class="line"><span class="comment">//		binaryTree.postOrder(); // 2,5,4,3,1</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//前序遍历</span></span><br><span class="line">		<span class="comment">//前序遍历的次数 ：4 </span></span><br><span class="line"><span class="comment">//		System.out.println("前序遍历方式~~~");</span></span><br><span class="line"><span class="comment">//		HeroNode resNode = binaryTree.preOrderSearch(5);</span></span><br><span class="line"><span class="comment">//		if (resNode != null) &#123;</span></span><br><span class="line"><span class="comment">//			System.out.printf("找到了，信息为 no=%d name=%s", resNode.getNo(), resNode.getName());</span></span><br><span class="line"><span class="comment">//		&#125; else &#123;</span></span><br><span class="line"><span class="comment">//			System.out.printf("没有找到 no = %d 的英雄", 5);</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//中序遍历查找</span></span><br><span class="line">		<span class="comment">//中序遍历3次</span></span><br><span class="line"><span class="comment">//		System.out.println("中序遍历方式~~~");</span></span><br><span class="line"><span class="comment">//		HeroNode resNode = binaryTree.infixOrderSearch(5);</span></span><br><span class="line"><span class="comment">//		if (resNode != null) &#123;</span></span><br><span class="line"><span class="comment">//			System.out.printf("找到了，信息为 no=%d name=%s", resNode.getNo(), resNode.getName());</span></span><br><span class="line"><span class="comment">//		&#125; else &#123;</span></span><br><span class="line"><span class="comment">//			System.out.printf("没有找到 no = %d 的英雄", 5);</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//后序遍历查找</span></span><br><span class="line">		<span class="comment">//后序遍历查找的次数  2次</span></span><br><span class="line"><span class="comment">//		System.out.println("后序遍历方式~~~");</span></span><br><span class="line"><span class="comment">//		HeroNode resNode = binaryTree.postOrderSearch(5);</span></span><br><span class="line"><span class="comment">//		if (resNode != null) &#123;</span></span><br><span class="line"><span class="comment">//			System.out.printf("找到了，信息为 no=%d name=%s", resNode.getNo(), resNode.getName());</span></span><br><span class="line"><span class="comment">//		&#125; else &#123;</span></span><br><span class="line"><span class="comment">//			System.out.printf("没有找到 no = %d 的英雄", 5);</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//测试一把删除结点</span></span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"删除前,前序遍历"</span>);</span><br><span class="line">		binaryTree.preOrder(); <span class="comment">//  1,2,3,5,4</span></span><br><span class="line">		binaryTree.delNode(<span class="number">5</span>);</span><br><span class="line">		<span class="comment">//binaryTree.delNode(3);</span></span><br><span class="line">		System.out.println(<span class="string">"删除后，前序遍历"</span>);</span><br><span class="line">		binaryTree.preOrder(); <span class="comment">// 1,2,3,4</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义BinaryTree 二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.root = root;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//删除结点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//如果只有一个root结点, 这里立即判断root是不是就是要删除结点</span></span><br><span class="line">			<span class="keyword">if</span>(root.getNo() == no) &#123;</span><br><span class="line">				root = <span class="keyword">null</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//递归删除</span></span><br><span class="line">				root.delNode(no);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"空树，不能删除~"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//前序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.root.preOrder();</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"二叉树为空，无法遍历"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//中序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.root.infixOrder();</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"二叉树为空，无法遍历"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//后序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.root.postOrder();</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"二叉树为空，无法遍历"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//前序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> root.preOrderSearch(no);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//中序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> HeroNode <span class="title">infixOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> root.infixOrderSearch(no);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//后序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> HeroNode <span class="title">postOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.root.postOrderSearch(no);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先创建HeroNode 结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> HeroNode left; <span class="comment">//默认null</span></span><br><span class="line">	<span class="keyword">private</span> HeroNode right; <span class="comment">//默认null</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.no = no;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> no;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.no = no;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> left;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.left = left;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.right = right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//递归删除结点</span></span><br><span class="line">	<span class="comment">//1.如果删除的节点是叶子节点，则删除该节点</span></span><br><span class="line">	<span class="comment">//2.如果删除的节点是非叶子节点，则删除该子树</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//思路</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 	1. 因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除结点.</span></span><br><span class="line"><span class="comment">			2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)</span></span><br><span class="line"><span class="comment">			3. 如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)</span></span><br><span class="line"><span class="comment">			4. 如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除</span></span><br><span class="line"><span class="comment">			5.  如果第4步也没有删除结点，则应当向右子树进行递归删除.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.no == no) &#123;</span><br><span class="line">			<span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//3.如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.no == no) &#123;</span><br><span class="line">			<span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//4.我们就需要向左子树进行递归删除</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.left.delNode(no);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//5.则应当向右子树进行递归删除</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.right.delNode(no);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//编写前序遍历的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="keyword">this</span>); <span class="comment">//先输出父结点</span></span><br><span class="line">		<span class="comment">//递归向左子树前序遍历</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.left.preOrder();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//递归向右子树前序遍历</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.right.preOrder();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//中序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//递归向左子树中序遍历</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//输出父结点</span></span><br><span class="line">		System.out.println(<span class="keyword">this</span>);</span><br><span class="line">		<span class="comment">//递归向右子树中序遍历</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//后序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.left.postOrder();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.right.postOrder();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//前序遍历查找</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> no 查找no</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 如果找到就返回该Node ,如果没有找到返回 null</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"进入前序遍历"</span>);</span><br><span class="line">		<span class="comment">//比较当前结点是不是</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//1.则判断当前结点的左子节点是否为空，如果不为空，则递归前序查找</span></span><br><span class="line">		<span class="comment">//2.如果左递归前序查找，找到结点，则返回</span></span><br><span class="line">		HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">			resNode = <span class="keyword">this</span>.left.preOrderSearch(no);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(resNode != <span class="keyword">null</span>) &#123;<span class="comment">//说明我们左子树找到</span></span><br><span class="line">			<span class="keyword">return</span> resNode;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//1.左递归前序查找，找到结点，则返回，否继续判断，</span></span><br><span class="line">		<span class="comment">//2.当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">			resNode = <span class="keyword">this</span>.right.preOrderSearch(no);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> resNode;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//中序遍历查找</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> HeroNode <span class="title">infixOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//判断当前结点的左子节点是否为空，如果不为空，则递归中序查找</span></span><br><span class="line">		HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">			resNode = <span class="keyword">this</span>.left.infixOrderSearch(no);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> resNode;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"进入中序查找"</span>);</span><br><span class="line">		<span class="comment">//如果找到，则返回，如果没有找到，就和当前结点比较，如果是则返回当前结点</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//否则继续进行右递归的中序查找</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">			resNode = <span class="keyword">this</span>.right.infixOrderSearch(no);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> resNode;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//后序遍历查找</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> HeroNode <span class="title">postOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//判断当前结点的左子节点是否为空，如果不为空，则递归后序查找</span></span><br><span class="line">		HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">			resNode = <span class="keyword">this</span>.left.postOrderSearch(no);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(resNode != <span class="keyword">null</span>) &#123;<span class="comment">//说明在左子树找到</span></span><br><span class="line">			<span class="keyword">return</span> resNode;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//如果左子树没有找到，则向右子树递归进行后序遍历查找</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">			resNode = <span class="keyword">this</span>.right.postOrderSearch(no);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> resNode;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"进入后序查找"</span>);</span><br><span class="line">		<span class="comment">//如果左右子树都没有找到，就比较当前结点是不是</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> resNode;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>



<h3 id="35-顺序存储二叉树"><a href="#35-顺序存储二叉树" class="headerlink" title="35.顺序存储二叉树"></a>35.顺序存储二叉树</h3><blockquote>
<p>顺序存储二叉树：</p>
<p>从数据存储来看，<strong>数组存储方式</strong>和<strong>树</strong></p>
<p><strong>的存储方式</strong>可以相互转换，即数组可</p>
<p>以转换成树，树也可以转换成数组，</p>
<p>看下边的示意图</p>
<p><img alt="image-20200203201729273" data-src="https://pic.downk.cc/item/5e6736cc98271cb2b8945ff4.png" class="lazyload"></p>
<p>要求:</p>
<p>1)右图的二叉树的结点，要求以数组<br>的方式来存放 arr : [1, 2, 3, 4, 5, 6, 6]</p>
<p>2)要求在遍历数组 arr时，仍然可以以<br><strong>前序遍历</strong>，<strong>中序遍历</strong>和<strong>后序遍历</strong>的<br>方式完成结点的遍历</p>
<p>顺序存储二叉树的<strong>特点</strong>:</p>
<p>1)顺序二叉树通常只考虑完全二叉树</p>
<p>2)第n个元素的左子节点为 2 * n + 1 </p>
<p>3)第n个元素的右子节点为 2 * n + 2</p>
<p>4)第n个元素的父节点为 (n-1) / 2</p>
<p>5)n : 表示二叉树中的第几个元素(按0开始编号<br>如上图所示)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrBinaryTreeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;;</span><br><span class="line">		<span class="comment">//创建一个 ArrBinaryTree</span></span><br><span class="line">		ArrBinaryTree arrBinaryTree = <span class="keyword">new</span> ArrBinaryTree(arr);</span><br><span class="line">		arrBinaryTree.preOrder(); <span class="comment">// 1,2,4,5,3,6,7</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个ArrayBinaryTree, 实现顺序存储二叉树遍历</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrBinaryTree</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] arr;<span class="comment">//存储数据结点的数组</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ArrBinaryTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.arr = arr;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//重载preOrder</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.preOrder(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//编写一个方法，完成顺序存储二叉树的前序遍历</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> index 数组的下标 </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//如果数组为空，或者 arr.length = 0</span></span><br><span class="line">		<span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"数组为空，不能按照二叉树的前序遍历"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//输出当前这个元素</span></span><br><span class="line">		System.out.println(arr[index]); </span><br><span class="line">		<span class="comment">//向左递归遍历</span></span><br><span class="line">		<span class="keyword">if</span>((index * <span class="number">2</span> + <span class="number">1</span>) &lt; arr.length) &#123;</span><br><span class="line">			preOrder(<span class="number">2</span> * index + <span class="number">1</span> );</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//向右递归遍历</span></span><br><span class="line">		<span class="keyword">if</span>((index * <span class="number">2</span> + <span class="number">2</span>) &lt; arr.length) &#123;</span><br><span class="line">			preOrder(<span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="36-线索化二叉树"><a href="#36-线索化二叉树" class="headerlink" title="36.线索化二叉树"></a>36.线索化二叉树</h3><blockquote>
<p><strong>线索二叉树基本介绍</strong></p>
<p>1)n个结点的二叉链表中含有n+1 【公式 2n-(n-1)=n+1】 个空指针域。利用二叉链表中的空指针域，存放指向<strong>该</strong><a href="https://baike.baidu.com/item/结点" target="_blank" rel="noopener">结</a><a href="https://baike.baidu.com/item/结点" target="_blank" rel="noopener">点</a>在<strong>某种遍历次序</strong>下的前驱和后继结点的指针（这种附加的指针称为”线索”）</p>
<p>2)这种加上了线索的二叉链表称为<strong>线索链表</strong>，相应的二叉树称为<strong>线索二叉树</strong>(Threaded<strong>*BinaryTree</strong>)<strong>。根据线索性质的不同，线索二叉树可分为</strong>前序线索二叉树、中序线索二叉树<strong>和</strong>后序线索二叉树**三种</p>
<p>3)一个结点的前一个结点，称为<strong>前驱</strong>结点</p>
<p>4)一个结点的后一个结点，称为<strong>后继</strong>结点</p>
<p><img alt="image-20200204221239791" data-src="https://pic.downk.cc/item/5e6736cc98271cb2b8945ffa.png" class="lazyload"></p>
<p><strong>说明</strong>: <strong>当线索化二叉树后，</strong>Node节点的 属性 <strong>left</strong> <strong>和</strong> <strong>right</strong>，有如下情况:</p>
<p>1)left 指向的是左子树，也可能是指向的前驱节点. 比如 ① 节点 left 指向的左子树, 而 ⑩ 节点的 left 指向的就是前驱节点.</p>
<p>2)right指向的是右子树，也可能是指向后继节点，比如 ① 节点right 指向的是右子树，而⑩ 节点的right 指向的是后继节点.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadedBinaryTreeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//测试一把中序线索二叉树的功能</span></span><br><span class="line">		HeroNode root = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">"tom"</span>);</span><br><span class="line">		HeroNode node2 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">"jack"</span>);</span><br><span class="line">		HeroNode node3 = <span class="keyword">new</span> HeroNode(<span class="number">6</span>, <span class="string">"smith"</span>);</span><br><span class="line">		HeroNode node4 = <span class="keyword">new</span> HeroNode(<span class="number">8</span>, <span class="string">"mary"</span>);</span><br><span class="line">		HeroNode node5 = <span class="keyword">new</span> HeroNode(<span class="number">10</span>, <span class="string">"king"</span>);</span><br><span class="line">		HeroNode node6 = <span class="keyword">new</span> HeroNode(<span class="number">14</span>, <span class="string">"dim"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//二叉树，后面我们要递归创建, 现在简单处理使用手动创建</span></span><br><span class="line">		root.setLeft(node2);</span><br><span class="line">		root.setRight(node3);</span><br><span class="line">		node2.setLeft(node4);</span><br><span class="line">		node2.setRight(node5);</span><br><span class="line">		node3.setLeft(node6);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//测试中序线索化</span></span><br><span class="line">		ThreadedBinaryTree threadedBinaryTree = <span class="keyword">new</span> ThreadedBinaryTree();</span><br><span class="line">		threadedBinaryTree.setRoot(root);</span><br><span class="line">		threadedBinaryTree.threadedNodes();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//测试: 以10号节点测试</span></span><br><span class="line">		HeroNode leftNode = node5.getLeft();</span><br><span class="line">		HeroNode rightNode = node5.getRight();</span><br><span class="line">		System.out.println(<span class="string">"10号结点的前驱结点是 ="</span>  + leftNode); <span class="comment">//3</span></span><br><span class="line">		System.out.println(<span class="string">"10号结点的后继结点是="</span>  + rightNode); <span class="comment">//1</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//当线索化二叉树后，能在使用原来的遍历方法</span></span><br><span class="line">		<span class="comment">//threadedBinaryTree.infixOrder();</span></span><br><span class="line">		System.out.println(<span class="string">"使用线索化的方式遍历 线索化二叉树"</span>);</span><br><span class="line">		threadedBinaryTree.threadedList(); <span class="comment">// 8, 3, 10, 1, 14, 6</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义ThreadedBinaryTree 实现了线索化功能的二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadedBinaryTree</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> HeroNode root;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//为了实现线索化，需要创建要给指向当前结点的前驱结点的指针</span></span><br><span class="line">	<span class="comment">//在递归进行线索化时，pre 总是保留前一个结点</span></span><br><span class="line">	<span class="keyword">private</span> HeroNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.root = root;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//重载一把threadedNodes方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedNodes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.threadedNodes(root);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//遍历线索化二叉树的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//定义一个变量，存储当前遍历的结点，从root开始</span></span><br><span class="line">		HeroNode node = root;</span><br><span class="line">		<span class="keyword">while</span>(node != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//循环的找到leftType == 1的结点，第一个找到就是8结点</span></span><br><span class="line">			<span class="comment">//后面随着遍历而变化,因为当leftType==1时，说明该结点是按照线索化</span></span><br><span class="line">			<span class="comment">//处理后的有效结点</span></span><br><span class="line">			<span class="keyword">while</span>(node.getLeftType() == <span class="number">0</span>) &#123;</span><br><span class="line">				node = node.getLeft();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//打印当前这个结点</span></span><br><span class="line">			System.out.println(node);</span><br><span class="line">			<span class="comment">//如果当前结点的右指针指向的是后继结点,就一直输出</span></span><br><span class="line">			<span class="keyword">while</span>(node.getRightType() == <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="comment">//获取到当前结点的后继结点</span></span><br><span class="line">				node = node.getRight();</span><br><span class="line">				System.out.println(node);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//替换这个遍历的结点</span></span><br><span class="line">			node = node.getRight();</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//编写对二叉树进行中序线索化的方法</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> node 就是当前需要线索化的结点</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedNodes</span><span class="params">(HeroNode node)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//如果node==null, 不能线索化</span></span><br><span class="line">		<span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//(一)先线索化左子树</span></span><br><span class="line">		threadedNodes(node.getLeft());</span><br><span class="line">		<span class="comment">//(二)线索化当前结点[有难度]</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//处理当前结点的前驱结点</span></span><br><span class="line">		<span class="comment">//以8结点来理解</span></span><br><span class="line">		<span class="comment">//8结点的.left = null , 8结点的.leftType = 1</span></span><br><span class="line">		<span class="keyword">if</span>(node.getLeft() == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//让当前结点的左指针指向前驱结点 </span></span><br><span class="line">			node.setLeft(pre); </span><br><span class="line">			<span class="comment">//修改当前结点的左指针的类型,指向前驱结点</span></span><br><span class="line">			node.setLeftType(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//处理后继结点</span></span><br><span class="line">		<span class="keyword">if</span> (pre != <span class="keyword">null</span> &amp;&amp; pre.getRight() == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//让前驱结点的右指针指向当前结点</span></span><br><span class="line">			pre.setRight(node);</span><br><span class="line">			<span class="comment">//修改前驱结点的右指针类型</span></span><br><span class="line">			pre.setRightType(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//!!! 每处理一个结点后，让当前结点是下一个结点的前驱结点</span></span><br><span class="line">		pre = node;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//(三)在线索化右子树</span></span><br><span class="line">		threadedNodes(node.getRight());</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//删除结点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//如果只有一个root结点, 这里立即判断root是不是就是要删除结点</span></span><br><span class="line">			<span class="keyword">if</span>(root.getNo() == no) &#123;</span><br><span class="line">				root = <span class="keyword">null</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//递归删除</span></span><br><span class="line">				root.delNode(no);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"空树，不能删除~"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//前序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.root.preOrder();</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"二叉树为空，无法遍历"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//中序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.root.infixOrder();</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"二叉树为空，无法遍历"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//后序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.root.postOrder();</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"二叉树为空，无法遍历"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//前序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> root.preOrderSearch(no);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//中序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> HeroNode <span class="title">infixOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> root.infixOrderSearch(no);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//后序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> HeroNode <span class="title">postOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.root.postOrderSearch(no);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先创建HeroNode 结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> HeroNode left; <span class="comment">//默认null</span></span><br><span class="line">	<span class="keyword">private</span> HeroNode right; <span class="comment">//默认null</span></span><br><span class="line">	<span class="comment">//说明</span></span><br><span class="line">	<span class="comment">//1. 如果leftType == 0 表示指向的是左子树, 如果 1 则表示指向前驱结点</span></span><br><span class="line">	<span class="comment">//2. 如果rightType == 0 表示指向是右子树, 如果 1表示指向后继结点</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> leftType;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> rightType;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLeftType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> leftType;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftType</span><span class="params">(<span class="keyword">int</span> leftType)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.leftType = leftType;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRightType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> rightType;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightType</span><span class="params">(<span class="keyword">int</span> rightType)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.rightType = rightType;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.no = no;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> no;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.no = no;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> left;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.left = left;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.right = right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//递归删除结点</span></span><br><span class="line">	<span class="comment">//1.如果删除的节点是叶子节点，则删除该节点</span></span><br><span class="line">	<span class="comment">//2.如果删除的节点是非叶子节点，则删除该子树</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//思路</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 	1. 因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除结点.</span></span><br><span class="line"><span class="comment">			1. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)</span></span><br><span class="line"><span class="comment">			2. 如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)</span></span><br><span class="line"><span class="comment">			3. 如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除</span></span><br><span class="line"><span class="comment">			4.  如果第4步也没有删除结点，则应当向右子树进行递归删除.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.no == no) &#123;</span><br><span class="line">			<span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//3.如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.no == no) &#123;</span><br><span class="line">			<span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//4.我们就需要向左子树进行递归删除</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.left.delNode(no);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//5.则应当向右子树进行递归删除</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.right.delNode(no);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//编写前序遍历的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="keyword">this</span>); <span class="comment">//先输出父结点</span></span><br><span class="line">		<span class="comment">//递归向左子树前序遍历</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.left.preOrder();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//递归向右子树前序遍历</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.right.preOrder();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//中序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//递归向左子树中序遍历</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//输出父结点</span></span><br><span class="line">		System.out.println(<span class="keyword">this</span>);</span><br><span class="line">		<span class="comment">//递归向右子树中序遍历</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//后序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.left.postOrder();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.right.postOrder();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//前序遍历查找</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> no 查找no</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 如果找到就返回该Node ,如果没有找到返回 null</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"进入前序遍历"</span>);</span><br><span class="line">		<span class="comment">//比较当前结点是不是</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//1.则判断当前结点的左子节点是否为空，如果不为空，则递归前序查找</span></span><br><span class="line">		<span class="comment">//2.如果左递归前序查找，找到结点，则返回</span></span><br><span class="line">		HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">			resNode = <span class="keyword">this</span>.left.preOrderSearch(no);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(resNode != <span class="keyword">null</span>) &#123;<span class="comment">//说明我们左子树找到</span></span><br><span class="line">			<span class="keyword">return</span> resNode;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//1.左递归前序查找，找到结点，则返回，否继续判断，</span></span><br><span class="line">		<span class="comment">//2.当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">			resNode = <span class="keyword">this</span>.right.preOrderSearch(no);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> resNode;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//中序遍历查找</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> HeroNode <span class="title">infixOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//判断当前结点的左子节点是否为空，如果不为空，则递归中序查找</span></span><br><span class="line">		HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">			resNode = <span class="keyword">this</span>.left.infixOrderSearch(no);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> resNode;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"进入中序查找"</span>);</span><br><span class="line">		<span class="comment">//如果找到，则返回，如果没有找到，就和当前结点比较，如果是则返回当前结点</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//否则继续进行右递归的中序查找</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">			resNode = <span class="keyword">this</span>.right.infixOrderSearch(no);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> resNode;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//后序遍历查找</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> HeroNode <span class="title">postOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//判断当前结点的左子节点是否为空，如果不为空，则递归后序查找</span></span><br><span class="line">		HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">			resNode = <span class="keyword">this</span>.left.postOrderSearch(no);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(resNode != <span class="keyword">null</span>) &#123;<span class="comment">//说明在左子树找到</span></span><br><span class="line">			<span class="keyword">return</span> resNode;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//如果左子树没有找到，则向右子树递归进行后序遍历查找</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">			resNode = <span class="keyword">this</span>.right.postOrderSearch(no);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> resNode;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"进入后序查找"</span>);</span><br><span class="line">		<span class="comment">//如果左右子树都没有找到，就比较当前结点是不是</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> resNode;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="37-堆排序"><a href="#37-堆排序" class="headerlink" title="37.堆排序"></a>37.堆排序</h3><blockquote>
<p>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。</p>
<p>2)堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆,注意:没有要求结点的左孩子的值和右孩子的值的大小关系。</p>
<p>3)每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆</p>
<p>4)大顶堆举例说明 </p>
<p><img alt="image-20200206162646228" data-src="https://pic.downk.cc/item/5e6736cc98271cb2b8945ffd.png" class="lazyload"></p>
<p>5)小顶堆举例说明 </p>
<p><img alt="image-20200206162726752" data-src="https://pic.downk.cc/item/5e67382e98271cb2b8951514.png" class="lazyload"></p>
<p>6)一般升序采用大顶堆，降序采用小顶堆 </p>
<p>堆排序的基本思想是：</p>
<p>1)将待排序序列构造成一个大顶堆</p>
<p>2)此时，整个序列的最大值就是堆顶的根节点。</p>
<p>3)将其与末尾元素进行交换，此时末尾就为最大值。</p>
<p>4)然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。</p>
<p>如此反复执行，便能得到一个有序序列了。可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//要求将数组进行升序排序</span></span><br><span class="line">		<span class="comment">//int arr[] = &#123;4, 6, 8, 5, 9&#125;;</span></span><br><span class="line">		<span class="comment">// 创建要给80000个的随机的数组</span></span><br><span class="line">		<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8000000</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8000000</span>; i++) &#123;</span><br><span class="line">			arr[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">8000000</span>); <span class="comment">// 生成一个[0, 8000000) 数</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"排序前"</span>);</span><br><span class="line">		Date data1 = <span class="keyword">new</span> Date();</span><br><span class="line">		SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">		String date1Str = simpleDateFormat.format(data1);</span><br><span class="line">		System.out.println(<span class="string">"排序前的时间是="</span> + date1Str);</span><br><span class="line">		</span><br><span class="line">		heapSort(arr);</span><br><span class="line">		</span><br><span class="line">		Date data2 = <span class="keyword">new</span> Date();</span><br><span class="line">		String date2Str = simpleDateFormat.format(data2);</span><br><span class="line">		System.out.println(<span class="string">"排序前的时间是="</span> + date2Str);</span><br><span class="line">		<span class="comment">//System.out.println("排序后=" + Arrays.toString(arr));</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//编写一个堆排序的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">		System.out.println(<span class="string">"堆排序!!"</span>);</span><br><span class="line">		</span><br><span class="line"><span class="comment">//		//分步完成</span></span><br><span class="line"><span class="comment">//		adjustHeap(arr, 1, arr.length);</span></span><br><span class="line"><span class="comment">//		System.out.println("第一次" + Arrays.toString(arr)); // 4, 9, 8, 5, 6</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//		adjustHeap(arr, 0, arr.length);</span></span><br><span class="line"><span class="comment">//		System.out.println("第2次" + Arrays.toString(arr)); // 9,6,8,5,4</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//完成我们最终代码</span></span><br><span class="line">		<span class="comment">//将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length / <span class="number">2</span> -<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">			adjustHeap(arr, i, arr.length);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 2).将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;</span></span><br><span class="line"><span class="comment">　　			3).重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = arr.length-<span class="number">1</span>;j &gt;<span class="number">0</span>; j--) &#123;</span><br><span class="line">			<span class="comment">//交换</span></span><br><span class="line">			temp = arr[j];</span><br><span class="line">			arr[j] = arr[<span class="number">0</span>];</span><br><span class="line">			arr[<span class="number">0</span>] = temp;</span><br><span class="line">			adjustHeap(arr, <span class="number">0</span>, j); </span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//System.out.println("数组=" + Arrays.toString(arr)); </span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将一个数组(二叉树), 调整成一个大顶堆</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 功能： 完成 将 以 i 对应的非叶子结点的树调整成大顶堆</span></span><br><span class="line"><span class="comment">	 * 举例  int arr[] = &#123;4, 6, 8, 5, 9&#125;; =&gt; i = 1 =&gt; adjustHeap =&gt; 得到 &#123;4, 9, 8, 5, 6&#125;</span></span><br><span class="line"><span class="comment">	 * 如果我们再次调用  adjustHeap 传入的是 i = 0 =&gt; 得到 &#123;4, 9, 8, 5, 6&#125; =&gt; &#123;9,6,8,5, 4&#125;</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> arr 待调整的数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> i 表示非叶子结点在数组中索引</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> lenght 表示对多少个元素继续调整， length 是在逐渐的减少</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> i, <span class="keyword">int</span> lenght)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> temp = arr[i];<span class="comment">//先取出当前元素的值，保存在临时变量</span></span><br><span class="line">		<span class="comment">//开始调整</span></span><br><span class="line">		<span class="comment">//说明</span></span><br><span class="line">		<span class="comment">//1. k = i * 2 + 1 k 是 i结点的左子结点</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k = i * <span class="number">2</span> + <span class="number">1</span>; k &lt; lenght; k = k * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(k+<span class="number">1</span> &lt; lenght &amp;&amp; arr[k] &lt; arr[k+<span class="number">1</span>]) &#123; <span class="comment">//说明左子结点的值小于右子结点的值</span></span><br><span class="line">				k++; <span class="comment">// k 指向右子结点</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(arr[k] &gt; temp) &#123; <span class="comment">//如果子结点大于父结点</span></span><br><span class="line">				arr[i] = arr[k]; <span class="comment">//把较大的值赋给当前结点</span></span><br><span class="line">				i = k; <span class="comment">//!!! i 指向 k,继续循环比较</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">//!</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//当for 循环结束后，我们已经将以i 为父结点的树的最大值，放在了 最顶(局部)</span></span><br><span class="line">		arr[i] = temp;<span class="comment">//将temp值放到调整后的位置</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="38-赫夫曼树"><a href="#38-赫夫曼树" class="headerlink" title="38.赫夫曼树"></a>38.赫夫曼树</h3><blockquote>
<p>赫夫曼树介绍：</p>
<p>1)给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(HuffmanTree),还有的书翻译为霍夫曼树。</p>
<p>2)赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近 </p>
<p>赫夫曼树几个重要概念：</p>
<p>1)路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路 </p>
<p>中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1</p>
<p>2)结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积</p>
<p>3)树的带权路径长度：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL(weightedpathlength),权值越大的结点离根结点越近的二叉树才是最优二叉树。</p>
<p>4)WPL最小的就是赫夫曼树 </p>
<p>构成赫夫曼树的步骤：</p>
<p>1)从小到大进行排序,将每一个数据，每个数据都是一个节点，每个节点可以看成是一颗最简单的二叉树</p>
<p>2)取出根节点权值最小的两颗二叉树</p>
<p>3)组成一颗新的二叉树,该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和 </p>
<p>4)再将这颗新的二叉树，以根节点的权值大小再次排序，不断重复1-2-3-4的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树</p>
<p>5)图解: </p>
<p><img alt="image-20200207141816547" data-src="https://pic.downk.cc/item/5e67382e98271cb2b8951517.png" class="lazyload"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanCode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//测试压缩文件</span></span><br><span class="line"><span class="comment">//		String srcFile = "d://Uninstall.xml";</span></span><br><span class="line"><span class="comment">//		String dstFile = "d://Uninstall.zip";</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//		zipFile(srcFile, dstFile);</span></span><br><span class="line"><span class="comment">//		System.out.println("压缩文件ok~~");</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//测试解压文件</span></span><br><span class="line">		String zipFile = <span class="string">"d://Uninstall.zip"</span>;</span><br><span class="line">		String dstFile = <span class="string">"d://Uninstall2.xml"</span>;</span><br><span class="line">		unZipFile(zipFile, dstFile);</span><br><span class="line">		System.out.println(<span class="string">"解压成功!"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		String content = "i like like like java do you like a java";</span></span><br><span class="line"><span class="comment">		byte[] contentBytes = content.getBytes();</span></span><br><span class="line"><span class="comment">		System.out.println(contentBytes.length); //40</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		byte[] huffmanCodesBytes= huffmanZip(contentBytes);</span></span><br><span class="line"><span class="comment">		System.out.println("压缩后的结果是:" + Arrays.toString(huffmanCodesBytes) + " 长度= " + huffmanCodesBytes.length);</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		//测试一把byteToBitString方法</span></span><br><span class="line"><span class="comment">		//System.out.println(byteToBitString((byte)1));</span></span><br><span class="line"><span class="comment">		byte[] sourceBytes = decode(huffmanCodes, huffmanCodesBytes);</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		System.out.println("原来的字符串=" + new String(sourceBytes)); // "i like like like java do you like a java"</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//如何将 数据进行解压(解码)  </span></span><br><span class="line">		<span class="comment">//分步过程</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		List&lt;Node&gt; nodes = getNodes(contentBytes);</span></span><br><span class="line"><span class="comment">		System.out.println("nodes=" + nodes);</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		//测试一把，创建的赫夫曼树</span></span><br><span class="line"><span class="comment">		System.out.println("赫夫曼树");</span></span><br><span class="line"><span class="comment">		Node huffmanTreeRoot = createHuffmanTree(nodes);</span></span><br><span class="line"><span class="comment">		System.out.println("前序遍历");</span></span><br><span class="line"><span class="comment">		huffmanTreeRoot.preOrder();</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		//测试一把是否生成了对应的赫夫曼编码</span></span><br><span class="line"><span class="comment">		Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTreeRoot);</span></span><br><span class="line"><span class="comment">		System.out.println("~生成的赫夫曼编码表= " + huffmanCodes);</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		//测试</span></span><br><span class="line"><span class="comment">		byte[] huffmanCodeBytes = zip(contentBytes, huffmanCodes);</span></span><br><span class="line"><span class="comment">		System.out.println("huffmanCodeBytes=" + Arrays.toString(huffmanCodeBytes));//17</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		//发送huffmanCodeBytes 数组 */</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//编写一个方法，完成对压缩文件的解压</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> zipFile 准备解压的文件</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> dstFile 将文件解压到哪个路径</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unZipFile</span><span class="params">(String zipFile, String dstFile)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//定义文件输入流</span></span><br><span class="line">		InputStream is = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">//定义一个对象输入流</span></span><br><span class="line">		ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">//定义文件的输出流</span></span><br><span class="line">		OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//创建文件输入流</span></span><br><span class="line">			is = <span class="keyword">new</span> FileInputStream(zipFile);</span><br><span class="line">			<span class="comment">//创建一个和  is关联的对象输入流</span></span><br><span class="line">			ois = <span class="keyword">new</span> ObjectInputStream(is);</span><br><span class="line">			<span class="comment">//读取byte数组  huffmanBytes</span></span><br><span class="line">			<span class="keyword">byte</span>[] huffmanBytes = (<span class="keyword">byte</span>[])ois.readObject();</span><br><span class="line">			<span class="comment">//读取赫夫曼编码表</span></span><br><span class="line">			Map&lt;Byte,String&gt; huffmanCodes = (Map&lt;Byte,String&gt;)ois.readObject();</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//解码</span></span><br><span class="line">			<span class="keyword">byte</span>[] bytes = decode(huffmanCodes, huffmanBytes);</span><br><span class="line">			<span class="comment">//将bytes 数组写入到目标文件</span></span><br><span class="line">			os = <span class="keyword">new</span> FileOutputStream(dstFile);</span><br><span class="line">			<span class="comment">//写数据到 dstFile 文件</span></span><br><span class="line">			os.write(bytes);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">			System.out.println(e.getMessage());</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				os.close();</span><br><span class="line">				ois.close();</span><br><span class="line">				is.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">				<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">				System.out.println(e2.getMessage());</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//编写方法，将一个文件进行压缩</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> srcFile 你传入的希望压缩的文件的全路径</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> dstFile 我们压缩后将压缩文件放到哪个目录</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zipFile</span><span class="params">(String srcFile, String dstFile)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//创建输出流</span></span><br><span class="line">		OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">		ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">//创建文件的输入流</span></span><br><span class="line">		FileInputStream is = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//创建文件的输入流</span></span><br><span class="line">			is = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line">			<span class="comment">//创建一个和源文件大小一样的byte[]</span></span><br><span class="line">			<span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">			<span class="comment">//读取文件</span></span><br><span class="line">			is.read(b);</span><br><span class="line">			<span class="comment">//直接对源文件压缩</span></span><br><span class="line">			<span class="keyword">byte</span>[] huffmanBytes = huffmanZip(b);</span><br><span class="line">			<span class="comment">//创建文件的输出流, 存放压缩文件</span></span><br><span class="line">			os = <span class="keyword">new</span> FileOutputStream(dstFile);</span><br><span class="line">			<span class="comment">//创建一个和文件输出流关联的ObjectOutputStream</span></span><br><span class="line">			oos = <span class="keyword">new</span> ObjectOutputStream(os);</span><br><span class="line">			<span class="comment">//把 赫夫曼编码后的字节数组写入压缩文件</span></span><br><span class="line">			oos.writeObject(huffmanBytes); <span class="comment">//我们是把</span></span><br><span class="line">			<span class="comment">//这里我们以对象流的方式写入 赫夫曼编码，是为了以后我们恢复源文件时使用</span></span><br><span class="line">			<span class="comment">//注意一定要把赫夫曼编码 写入压缩文件</span></span><br><span class="line">			oos.writeObject(huffmanCodes);</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">		&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">			System.out.println(e.getMessage());</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				is.close();</span><br><span class="line">				oos.close();</span><br><span class="line">				os.close();</span><br><span class="line">			&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">				System.out.println(e.getMessage());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//完成数据的解压</span></span><br><span class="line">	<span class="comment">//思路</span></span><br><span class="line">	<span class="comment">//1. 将huffmanCodeBytes [-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]</span></span><br><span class="line">	<span class="comment">//   重写先转成 赫夫曼编码对应的二进制的字符串 "1010100010111..."</span></span><br><span class="line">	<span class="comment">//2.  赫夫曼编码对应的二进制的字符串 "1010100010111..." =》 对照 赫夫曼编码  =》 "i like like like java do you like a java"</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//编写一个方法，完成对压缩数据的解码</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> huffmanCodes 赫夫曼编码表 map</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> huffmanBytes 赫夫曼编码得到的字节数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 就是原来的字符串对应的数组</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decode(Map&lt;Byte,String&gt; huffmanCodes, <span class="keyword">byte</span>[] huffmanBytes) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//1. 先得到 huffmanBytes 对应的 二进制的字符串 ， 形式 1010100010111...</span></span><br><span class="line">		StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="comment">//将byte数组转成二进制的字符串</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; huffmanBytes.length; i++) &#123;</span><br><span class="line">			<span class="keyword">byte</span> b = huffmanBytes[i];</span><br><span class="line">			<span class="comment">//判断是不是最后一个字节</span></span><br><span class="line">			<span class="keyword">boolean</span> flag = (i == huffmanBytes.length - <span class="number">1</span>);</span><br><span class="line">			stringBuilder.append(byteToBitString(!flag, b));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//把字符串安装指定的赫夫曼编码进行解码</span></span><br><span class="line">		<span class="comment">//把赫夫曼编码表进行调换，因为反向查询 a-&gt;100 100-&gt;a</span></span><br><span class="line">		Map&lt;String, Byte&gt;  map = <span class="keyword">new</span> HashMap&lt;String,Byte&gt;();</span><br><span class="line">		<span class="keyword">for</span>(Map.Entry&lt;Byte, String&gt; entry: huffmanCodes.entrySet()) &#123;</span><br><span class="line">			map.put(entry.getValue(), entry.getKey());</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//创建要给集合，存放byte</span></span><br><span class="line">		List&lt;Byte&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="comment">//i 可以理解成就是索引,扫描 stringBuilder </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span>  i = <span class="number">0</span>; i &lt; stringBuilder.length(); ) &#123;</span><br><span class="line">			<span class="keyword">int</span> count = <span class="number">1</span>; <span class="comment">// 小的计数器</span></span><br><span class="line">			<span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">			Byte b = <span class="keyword">null</span>;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">while</span>(flag) &#123;</span><br><span class="line">				<span class="comment">//1010100010111...</span></span><br><span class="line">				<span class="comment">//递增的取出 key 1 </span></span><br><span class="line">				String key = stringBuilder.substring(i, i+count);<span class="comment">//i 不动，让count移动，指定匹配到一个字符</span></span><br><span class="line">				b = map.get(key);</span><br><span class="line">				<span class="keyword">if</span>(b == <span class="keyword">null</span>) &#123;<span class="comment">//说明没有匹配到</span></span><br><span class="line">					count++;</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">//匹配到</span></span><br><span class="line">					flag = <span class="keyword">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			list.add(b);</span><br><span class="line">			i += count;<span class="comment">//i 直接移动到 count	</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//当for循环结束后，我们list中就存放了所有的字符  "i like like like java do you like a java"</span></span><br><span class="line">		<span class="comment">//把list 中的数据放入到byte[] 并返回</span></span><br><span class="line">		<span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[list.size()];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; b.length; i++) &#123;</span><br><span class="line">			b[i] = list.get(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> b;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"> 	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将一个byte 转成一个二进制的字符串, 如果看不懂，可以参考我讲的Java基础 二进制的原码，反码，补码</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> b 传入的 byte</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> flag 标志是否需要补高位如果是true ，表示需要补高位，如果是false表示不补, 如果是最后一个字节，无需补高位</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 是该b 对应的二进制的字符串，（注意是按补码返回）</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">byteToBitString</span><span class="params">(<span class="keyword">boolean</span> flag, <span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//使用变量保存 b</span></span><br><span class="line">		<span class="keyword">int</span> temp = b; <span class="comment">//将 b 转成 int</span></span><br><span class="line">		<span class="comment">//如果是正数我们还存在补高位</span></span><br><span class="line">		<span class="keyword">if</span>(flag) &#123;</span><br><span class="line">			temp |= <span class="number">256</span>; <span class="comment">//按位与 256  1 0000 0000  | 0000 0001 =&gt; 1 0000 0001</span></span><br><span class="line">		&#125;</span><br><span class="line">		String str = Integer.toBinaryString(temp); <span class="comment">//返回的是temp对应的二进制的补码</span></span><br><span class="line">		<span class="keyword">if</span>(flag) &#123;</span><br><span class="line">			<span class="keyword">return</span> str.substring(str.length() - <span class="number">8</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> str;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//使用一个方法，将前面的方法封装起来，便于我们的调用.</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bytes 原始的字符串对应的字节数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 是经过 赫夫曼编码处理后的字节数组(压缩后的数组)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] huffmanZip(<span class="keyword">byte</span>[] bytes) &#123;</span><br><span class="line">		List&lt;Node&gt; nodes = getNodes(bytes);</span><br><span class="line">		<span class="comment">//根据 nodes 创建的赫夫曼树</span></span><br><span class="line">		Node huffmanTreeRoot = createHuffmanTree(nodes);</span><br><span class="line">		<span class="comment">//对应的赫夫曼编码(根据 赫夫曼树)</span></span><br><span class="line">		Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTreeRoot);</span><br><span class="line">		<span class="comment">//根据生成的赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组</span></span><br><span class="line">		<span class="keyword">byte</span>[] huffmanCodeBytes = zip(bytes, huffmanCodes);</span><br><span class="line">		<span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//编写一个方法，将字符串对应的byte[] 数组，通过生成的赫夫曼编码表，返回一个赫夫曼编码 压缩后的byte[]</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bytes 这时原始的字符串对应的 byte[]</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> huffmanCodes 生成的赫夫曼编码map</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 返回赫夫曼编码处理后的 byte[] </span></span><br><span class="line"><span class="comment">	 * 举例： String content = "i like like like java do you like a java"; =》 byte[] contentBytes = content.getBytes();</span></span><br><span class="line"><span class="comment">	 * 返回的是 字符串 "1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100"</span></span><br><span class="line"><span class="comment">	 * =&gt; 对应的 byte[] huffmanCodeBytes  ，即 8位对应一个 byte,放入到 huffmanCodeBytes</span></span><br><span class="line"><span class="comment">	 * huffmanCodeBytes[0] =  10101000(补码) =&gt; byte  [推导  10101000=&gt; 10101000 - 1 =&gt; 10100111(反码)=&gt; 11011000= -88 ]</span></span><br><span class="line"><span class="comment">	 * huffmanCodeBytes[1] = -88</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] zip(<span class="keyword">byte</span>[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//1.利用 huffmanCodes 将  bytes 转成  赫夫曼编码对应的字符串</span></span><br><span class="line">		StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="comment">//遍历bytes 数组 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">byte</span> b: bytes) &#123;</span><br><span class="line">			stringBuilder.append(huffmanCodes.get(b));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//System.out.println("测试 stringBuilder~~~=" + stringBuilder.toString());</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将 "1010100010111111110..." 转成 byte[]</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//统计返回  byte[] huffmanCodeBytes 长度</span></span><br><span class="line">		<span class="comment">//一句话 int len = (stringBuilder.length() + 7) / 8;</span></span><br><span class="line">		<span class="keyword">int</span> len;</span><br><span class="line">		<span class="keyword">if</span>(stringBuilder.length() % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">			len = stringBuilder.length() / <span class="number">8</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			len = stringBuilder.length() / <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//创建 存储压缩后的 byte数组</span></span><br><span class="line">		<span class="keyword">byte</span>[] huffmanCodeBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">		<span class="keyword">int</span> index = <span class="number">0</span>;<span class="comment">//记录是第几个byte</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringBuilder.length(); i += <span class="number">8</span>) &#123; <span class="comment">//因为是每8位对应一个byte,所以步长 +8</span></span><br><span class="line">				String strByte;</span><br><span class="line">				<span class="keyword">if</span>(i+<span class="number">8</span> &gt; stringBuilder.length()) &#123;<span class="comment">//不够8位</span></span><br><span class="line">					strByte = stringBuilder.substring(i);</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					strByte = stringBuilder.substring(i, i + <span class="number">8</span>);</span><br><span class="line">				&#125;	</span><br><span class="line">				<span class="comment">//将strByte 转成一个byte,放入到 huffmanCodeBytes</span></span><br><span class="line">				huffmanCodeBytes[index] = (<span class="keyword">byte</span>)Integer.parseInt(strByte, <span class="number">2</span>);</span><br><span class="line">				index++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//生成赫夫曼树对应的赫夫曼编码</span></span><br><span class="line">	<span class="comment">//思路:</span></span><br><span class="line">	<span class="comment">//1. 将赫夫曼编码表存放在 Map&lt;Byte,String&gt; 形式</span></span><br><span class="line">	<span class="comment">//   生成的赫夫曼编码表&#123;32=01, 97=100, 100=11000, 117=11001, 101=1110, 118=11011, 105=101, 121=11010, 106=0010, 107=1111, 108=000, 111=0011&#125;</span></span><br><span class="line">	<span class="keyword">static</span> Map&lt;Byte, String&gt; huffmanCodes = <span class="keyword">new</span> HashMap&lt;Byte,String&gt;();</span><br><span class="line">	<span class="comment">//2. 在生成赫夫曼编码表示，需要去拼接路径, 定义一个StringBuilder 存储某个叶子结点的路径</span></span><br><span class="line">	<span class="keyword">static</span> StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//为了调用方便，我们重载 getCodes</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte, String&gt; <span class="title">getCodes</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//处理root的左子树</span></span><br><span class="line">		getCodes(root.left, <span class="string">"0"</span>, stringBuilder);</span><br><span class="line">		<span class="comment">//处理root的右子树</span></span><br><span class="line">		getCodes(root.right, <span class="string">"1"</span>, stringBuilder);</span><br><span class="line">		<span class="keyword">return</span> huffmanCodes;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 功能：将传入的node结点的所有叶子结点的赫夫曼编码得到，并放入到huffmanCodes集合</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> node  传入结点</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> code  路径： 左子结点是 0, 右子结点 1</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> stringBuilder 用于拼接路径</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getCodes</span><span class="params">(Node node, String code, StringBuilder stringBuilder)</span> </span>&#123;</span><br><span class="line">		StringBuilder stringBuilder2 = <span class="keyword">new</span> StringBuilder(stringBuilder);</span><br><span class="line">		<span class="comment">//将code 加入到 stringBuilder2</span></span><br><span class="line">		stringBuilder2.append(code);</span><br><span class="line">		<span class="keyword">if</span>(node != <span class="keyword">null</span>) &#123; <span class="comment">//如果node == null不处理</span></span><br><span class="line">			<span class="comment">//判断当前node 是叶子结点还是非叶子结点</span></span><br><span class="line">			<span class="keyword">if</span>(node.data == <span class="keyword">null</span>) &#123; <span class="comment">//非叶子结点</span></span><br><span class="line">				<span class="comment">//递归处理</span></span><br><span class="line">				<span class="comment">//向左递归</span></span><br><span class="line">				getCodes(node.left, <span class="string">"0"</span>, stringBuilder2);</span><br><span class="line">				<span class="comment">//向右递归</span></span><br><span class="line">				getCodes(node.right, <span class="string">"1"</span>, stringBuilder2);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">//说明是一个叶子结点</span></span><br><span class="line">				<span class="comment">//就表示找到某个叶子结点的最后</span></span><br><span class="line">				huffmanCodes.put(node.data, stringBuilder2.toString());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//前序遍历的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">			root.preOrder();</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"赫夫曼树为空"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bytes 接收字节数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 返回的就是 List 形式   [Node[date=97 ,weight = 5], Node[]date=32,weight = 9]......],</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title">getNodes</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//1创建一个ArrayList</span></span><br><span class="line">		ArrayList&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//遍历 bytes , 统计 每一个byte出现的次数-&gt;map[key,value]</span></span><br><span class="line">		Map&lt;Byte, Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">byte</span> b : bytes) &#123;</span><br><span class="line">			Integer count = counts.get(b);</span><br><span class="line">			<span class="keyword">if</span> (count == <span class="keyword">null</span>) &#123; <span class="comment">// Map还没有这个字符数据,第一次</span></span><br><span class="line">				counts.put(b, <span class="number">1</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				counts.put(b, count + <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//把每一个键值对转成一个Node 对象，并加入到nodes集合</span></span><br><span class="line">		<span class="comment">//遍历map</span></span><br><span class="line">		<span class="keyword">for</span>(Map.Entry&lt;Byte, Integer&gt; entry: counts.entrySet()) &#123;</span><br><span class="line">			nodes.add(<span class="keyword">new</span> Node(entry.getKey(), entry.getValue()));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> nodes;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//可以通过List 创建对应的赫夫曼树</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">createHuffmanTree</span><span class="params">(List&lt;Node&gt; nodes)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">//排序, 从小到大</span></span><br><span class="line">			Collections.sort(nodes);</span><br><span class="line">			<span class="comment">//取出第一颗最小的二叉树</span></span><br><span class="line">			Node leftNode = nodes.get(<span class="number">0</span>);</span><br><span class="line">			<span class="comment">//取出第二颗最小的二叉树</span></span><br><span class="line">			Node rightNode = nodes.get(<span class="number">1</span>);</span><br><span class="line">			<span class="comment">//创建一颗新的二叉树,它的根节点 没有data, 只有权值</span></span><br><span class="line">			Node parent = <span class="keyword">new</span> Node(<span class="keyword">null</span>, leftNode.weight + rightNode.weight);</span><br><span class="line">			parent.left = leftNode;</span><br><span class="line">			parent.right = rightNode;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//将已经处理的两颗二叉树从nodes删除</span></span><br><span class="line">			nodes.remove(leftNode);</span><br><span class="line">			nodes.remove(rightNode);</span><br><span class="line">			<span class="comment">//将新的二叉树，加入到nodes</span></span><br><span class="line">			nodes.add(parent);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//nodes 最后的结点，就是赫夫曼树的根结点</span></span><br><span class="line">		<span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Node ,待数据和权值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt;  </span>&#123;</span><br><span class="line">	Byte data; <span class="comment">// 存放数据(字符)本身，比如'a' =&gt; 97 ' ' =&gt; 32</span></span><br><span class="line">	<span class="keyword">int</span> weight; <span class="comment">//权值, 表示字符出现的次数</span></span><br><span class="line">	Node left;<span class="comment">//</span></span><br><span class="line">	Node right;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Byte data, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">this</span>.data = data;</span><br><span class="line">		<span class="keyword">this</span>.weight = weight;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 从小到大排序</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.weight - o.weight;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Node [data = "</span> + data + <span class="string">" weight="</span> + weight + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//前序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="keyword">this</span>);</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.left.preOrder();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.right.preOrder();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="39-图"><a href="#39-图" class="headerlink" title="39.图"></a>39.图</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;<span class="comment">// 存储顶点集合</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[][] edges;<span class="comment">// 存储图的邻接矩阵</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> numOfEdges;<span class="comment">// 表示边的数目</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//测试一遍图是否创建ok</span></span><br><span class="line">		<span class="keyword">int</span> n = <span class="number">5</span>;<span class="comment">//节点的个数</span></span><br><span class="line">		String VertexValue[]= &#123;<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>,<span class="string">"D"</span>,<span class="string">"E"</span>&#125;;</span><br><span class="line">		<span class="comment">//创建图对象</span></span><br><span class="line">		Graph graph = <span class="keyword">new</span> Graph(n);</span><br><span class="line">		<span class="keyword">for</span>(String value:VertexValue)&#123;</span><br><span class="line">			graph.insertVertex(value);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//添加边 A-B A-C B-C B-D B-E</span></span><br><span class="line">		graph.insertEdge(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">		graph.insertEdge(<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">		graph.insertEdge(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">		graph.insertEdge(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">		graph.insertEdge(<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">		graph.showGraph();</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 初始化矩阵和vertexList</span></span><br><span class="line">		edges = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">		vertexList = <span class="keyword">new</span> ArrayList&lt;String&gt;(n);</span><br><span class="line">		numOfEdges = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//图中常用的方法</span></span><br><span class="line">	<span class="comment">//返回节点的个数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfVertex</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> vertexList.size();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//显示图对应的矩阵</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> link[]:edges)&#123;</span><br><span class="line">			System.out.println(Arrays.toString(link));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//得到边的数目</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfEdges</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> numOfEdges;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//返回节点i(下标)对应的数据 0-&gt;A , 1-&gt;B</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getValueByIndex</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//返回 v1 和 v2 的权值</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 插入节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertVertex</span><span class="params">(String vertex)</span> </span>&#123;</span><br><span class="line">		vertexList.add(vertex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> v1	  表示点的下标即 是第几个顶点</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> v2	  第二个顶点对应的下标</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> weight 表示权值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">		edges[v1][v2] = weight;</span><br><span class="line">		edges[v2][v1] = weight;</span><br><span class="line">		numOfEdges++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="40-图的深度优先遍历-DFS"><a href="#40-图的深度优先遍历-DFS" class="headerlink" title="40.图的深度优先遍历 DFS"></a>40.图的深度优先遍历 DFS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;<span class="comment">// 存储顶点集合</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[][] edges;<span class="comment">// 存储图的邻接矩阵</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> numOfEdges;<span class="comment">// 表示边的数目</span></span><br><span class="line">	<span class="comment">// 定义一个数组boolean[],记录某个节点是否被访问</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> isVisited[];</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 测试一遍图是否创建ok</span></span><br><span class="line">		<span class="keyword">int</span> n = <span class="number">5</span>;<span class="comment">// 节点的个数</span></span><br><span class="line">		String VertexValue[] = &#123; <span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span> &#125;;</span><br><span class="line">		<span class="comment">// 创建图对象</span></span><br><span class="line">		Graph graph = <span class="keyword">new</span> Graph(n);</span><br><span class="line">		<span class="keyword">for</span> (String value : VertexValue) &#123;</span><br><span class="line">			graph.insertVertex(value);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 添加边 A-B A-C B-C B-D B-E</span></span><br><span class="line">		graph.insertEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">		graph.insertEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">		graph.insertEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">		graph.insertEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">		graph.insertEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		graph.showGraph();</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"深度遍历"</span>);</span><br><span class="line">		graph.dfs();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 初始化矩阵和vertexList</span></span><br><span class="line">		edges = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">		vertexList = <span class="keyword">new</span> ArrayList&lt;String&gt;(n);</span><br><span class="line">		numOfEdges = <span class="number">0</span>;</span><br><span class="line">		isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 得到第一个邻接节点的下标w</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 如果存在就返回对应的下标，否则返回 -1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFirstNeighbor</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vertexList.size(); j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (edges[index][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据前一个邻接节点的下标来获取下一个邻接节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNextNeighbor</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = v2 + <span class="number">1</span>; j &lt; vertexList.size(); j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (edges[v1][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 深度优先遍历算法</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[] isVisited, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 首先我们访问该节点，输出</span></span><br><span class="line">		System.out.print(getValueByIndex(i) + <span class="string">"-&gt;"</span>);</span><br><span class="line">		<span class="comment">// 将节点设置为已经访问过的</span></span><br><span class="line">		isVisited[i] = <span class="keyword">true</span>;</span><br><span class="line">		<span class="comment">// 查找节点i的第一个邻接节点w</span></span><br><span class="line">		<span class="keyword">int</span> w = getFirstNeighbor(i);</span><br><span class="line">		<span class="keyword">while</span> (w != -<span class="number">1</span>) &#123;<span class="comment">// 说明有</span></span><br><span class="line">			<span class="keyword">if</span> (!isVisited[w]) &#123;</span><br><span class="line">				dfs(isVisited, w);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 如果节点w已经被访问过</span></span><br><span class="line">			w = getNextNeighbor(i, w);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对 dfs 进行一个重载，遍历我们所有节点，并进行 dfs</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 遍历所有的节点，进行 dfs[回溯]</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getNumOfVertex(); i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!isVisited[i]) &#123;</span><br><span class="line">				dfs(isVisited, i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 图中常用的方法</span></span><br><span class="line">	<span class="comment">// 返回节点的个数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfVertex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> vertexList.size();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示图对应的矩阵</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> link[] : edges) &#123;</span><br><span class="line">			System.out.println(Arrays.toString(link));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 得到边的数目</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfEdges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> numOfEdges;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回节点i(下标)对应的数据 0-&gt;A , 1-&gt;B</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getValueByIndex</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回 v1 和 v2 的权值</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 插入节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertVertex</span><span class="params">(String vertex)</span> </span>&#123;</span><br><span class="line">		vertexList.add(vertex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> v1</span></span><br><span class="line"><span class="comment">	 *            表示点的下标即 是第几个顶点</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> v2</span></span><br><span class="line"><span class="comment">	 *            第二个顶点对应的下标</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> weight</span></span><br><span class="line"><span class="comment">	 *            表示权值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">		edges[v1][v2] = weight;</span><br><span class="line">		edges[v2][v1] = weight;</span><br><span class="line">		numOfEdges++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="程序员常用的十种算法"><a href="#程序员常用的十种算法" class="headerlink" title="程序员常用的十种算法"></a>程序员常用的十种算法</h2><h3 id="41-二分查找-非递归"><a href="#41-二分查找-非递归" class="headerlink" title="41.二分查找(非递归)"></a>41.二分查找(非递归)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">		System.out.println(binarySearch(arr, <span class="number">5</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">	 *            待查找的数组，arr是升序排列</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">	 *            需要查找的数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 返回对应的下标，-1表示没有找到</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (left &lt;= right) &#123;<span class="comment">// 说明继续查找</span></span><br><span class="line">			<span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (arr[mid] == target) &#123;</span><br><span class="line">				<span class="keyword">return</span> mid;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target) &#123;</span><br><span class="line">				right = mid - <span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">				left = mid + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="42-分治算法-汉诺塔"><a href="#42-分治算法-汉诺塔" class="headerlink" title="42.分治算法(汉诺塔)"></a>42.分治算法(汉诺塔)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HanoTower</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		hanoTower(<span class="number">5</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanoTower</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">char</span> a, <span class="keyword">char</span> b, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 如果只有一个盘</span></span><br><span class="line">		<span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"第1个盘从"</span> + a + <span class="string">"-&gt;"</span> + c);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 如果我们有 n &gt;= 2 的情况，我们总是可以看做是两个盘</span></span><br><span class="line">			<span class="comment">// 1.最下边一个盘 2.上面的所有盘</span></span><br><span class="line">			<span class="comment">// 1.先把最上面所有盘A-&gt;B，移动过程中会用到C塔</span></span><br><span class="line">			hanoTower(num - <span class="number">1</span>, a, c, b);</span><br><span class="line">			<span class="comment">// 2.把最下面的盘A-&gt;C</span></span><br><span class="line">			System.out.println(<span class="string">"第"</span> + num + <span class="string">"个盘从"</span> + a + <span class="string">"-&gt;"</span> + c);</span><br><span class="line">			<span class="comment">// 3.把B塔的所有盘 从 B-&gt;C，移动过程中使用到A塔</span></span><br><span class="line">			hanoTower(num - <span class="number">1</span>, b, a, c);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="43-动态规划"><a href="#43-动态规划" class="headerlink" title="43.动态规划"></a>43.动态规划</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KnapsackProblem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">int</span>[] w = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;<span class="comment">//物品的重量</span></span><br><span class="line">		<span class="keyword">int</span>[] val = &#123;<span class="number">1500</span>, <span class="number">3000</span>, <span class="number">2000</span>&#125;; <span class="comment">//物品的价值 这里val[i] 就是前面讲的v[i]</span></span><br><span class="line">		<span class="keyword">int</span> m = <span class="number">4</span>; <span class="comment">//背包的容量</span></span><br><span class="line">		<span class="keyword">int</span> n = val.length; <span class="comment">//物品的个数</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//创建二维数组，</span></span><br><span class="line">		<span class="comment">//v[i][j] 表示在前i个物品中能够装入容量为j的背包中的最大价值</span></span><br><span class="line">		<span class="keyword">int</span>[][] v = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">		<span class="comment">//为了记录放入商品的情况，我们定一个二维数组</span></span><br><span class="line">		<span class="keyword">int</span>[][] path = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//初始化第一行和第一列, 这里在本程序中，可以不去处理，因为默认就是0</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.length; i++) &#123;</span><br><span class="line">			v[i][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//将第一列设置为0</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; v[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">			v[<span class="number">0</span>][i] = <span class="number">0</span>; <span class="comment">//将第一行设置0</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//根据前面得到公式来动态规划处理</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.length; i++) &#123; <span class="comment">//不处理第一行 i是从1开始的</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j &lt; v[<span class="number">0</span>].length; j++) &#123;<span class="comment">//不处理第一列, j是从1开始的</span></span><br><span class="line">				<span class="comment">//公式</span></span><br><span class="line">				<span class="keyword">if</span>(w[i-<span class="number">1</span>]&gt; j) &#123; <span class="comment">// 因为我们程序i 是从1开始的，因此原来公式中的 w[i] 修改成 w[i-1]</span></span><br><span class="line">					v[i][j]=v[i-<span class="number">1</span>][j];</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">//说明:</span></span><br><span class="line">					<span class="comment">//因为我们的i 从1开始的， 因此公式需要调整成</span></span><br><span class="line">					<span class="comment">//v[i][j]=Math.max(v[i-1][j], val[i-1]+v[i-1][j-w[i-1]]);</span></span><br><span class="line">					<span class="comment">//v[i][j] = Math.max(v[i - 1][j], val[i - 1] + v[i - 1][j - w[i - 1]]);</span></span><br><span class="line">					<span class="comment">//为了记录商品存放到背包的情况，我们不能直接的使用上面的公式，需要使用if-else来体现公式</span></span><br><span class="line">					<span class="keyword">if</span>(v[i - <span class="number">1</span>][j] &lt; val[i - <span class="number">1</span>] + v[i - <span class="number">1</span>][j - w[i - <span class="number">1</span>]]) &#123;</span><br><span class="line">						v[i][j] = val[i - <span class="number">1</span>] + v[i - <span class="number">1</span>][j - w[i - <span class="number">1</span>]];</span><br><span class="line">						<span class="comment">//把当前的情况记录到path</span></span><br><span class="line">						path[i][j] = <span class="number">1</span>;</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						v[i][j] = v[i - <span class="number">1</span>][j];</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//输出一下v 看看目前的情况</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; v.length;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v[i].length;j++) &#123;</span><br><span class="line">				System.out.print(v[i][j] + <span class="string">" "</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"============================"</span>);</span><br><span class="line">		<span class="comment">//输出最后我们是放入的哪些商品</span></span><br><span class="line">		<span class="comment">//遍历path, 这样输出会把所有的放入情况都得到, 其实我们只需要最后的放入</span></span><br><span class="line"><span class="comment">//		for(int i = 0; i &lt; path.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//			for(int j=0; j &lt; path[i].length; j++) &#123;</span></span><br><span class="line"><span class="comment">//				if(path[i][j] == 1) &#123;</span></span><br><span class="line"><span class="comment">//					System.out.printf("第%d个商品放入到背包\n", i);</span></span><br><span class="line"><span class="comment">//				&#125;</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//动脑筋</span></span><br><span class="line">		<span class="keyword">int</span> i = path.length - <span class="number">1</span>; <span class="comment">//行的最大下标</span></span><br><span class="line">		<span class="keyword">int</span> j = path[<span class="number">0</span>].length - <span class="number">1</span>;  <span class="comment">//列的最大下标</span></span><br><span class="line">		<span class="keyword">while</span>(i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span> ) &#123; <span class="comment">//从path的最后开始找</span></span><br><span class="line">			<span class="keyword">if</span>(path[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">				System.out.printf(<span class="string">"第%d个商品放入到背包\n"</span>, i); </span><br><span class="line">				j -= w[i-<span class="number">1</span>]; <span class="comment">//w[i-1]</span></span><br><span class="line">			&#125;</span><br><span class="line">			i--;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="44-暴力匹配"><a href="#44-暴力匹配" class="headerlink" title="44.暴力匹配"></a>44.暴力匹配</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViolenceMatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="comment">//测试暴力匹配算法</span></span><br><span class="line">		String str1 = <span class="string">"硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好"</span>;</span><br><span class="line">		String str2 = <span class="string">"尚硅谷你尚硅你~"</span>;</span><br><span class="line">		<span class="keyword">int</span> index = violenceMatch(str1, str2);</span><br><span class="line">		System.out.println(<span class="string">"index="</span> + index);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 暴力匹配算法实现</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">violenceMatch</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">char</span>[] s1 = str1.toCharArray();</span><br><span class="line">		<span class="keyword">char</span>[] s2 = str2.toCharArray();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> s1Len = s1.length;</span><br><span class="line">		<span class="keyword">int</span> s2Len = s2.length;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// i索引指向s1</span></span><br><span class="line">		<span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// j索引指向s2</span></span><br><span class="line">		<span class="keyword">while</span> (i &lt; s1Len &amp;&amp; j &lt; s2Len) &#123;<span class="comment">// 保证匹配时，不越界</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(s1[i] == s2[j]) &#123;<span class="comment">//匹配ok</span></span><br><span class="line">				i++;</span><br><span class="line">				j++;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">//没有匹配成功</span></span><br><span class="line">				<span class="comment">//如果失配（即str1[i]! = str2[j]），令i = i - (j - 1)，j = 0。</span></span><br><span class="line">				i = i - (j - <span class="number">1</span>);</span><br><span class="line">				j = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//判断是否匹配成功</span></span><br><span class="line">		<span class="keyword">if</span>(j == s2Len) &#123;</span><br><span class="line">			<span class="keyword">return</span> i - j;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="45-kmp算法"><a href="#45-kmp算法" class="headerlink" title="45.kmp算法"></a>45.kmp算法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KMPAlgorithm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		String str1 = <span class="string">"BBC ABCDAB ABCDABCDABDE"</span>;</span><br><span class="line">		String str2 = <span class="string">"ABCDABD"</span>;</span><br><span class="line">		<span class="comment">//String str2 = "BBC";</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span>[] next = kmpNext(<span class="string">"ABCDABD"</span>); <span class="comment">//[0, 1, 2, 0]</span></span><br><span class="line">		System.out.println(<span class="string">"next="</span> + Arrays.toString(next));</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> index = kmpSearch(str1, str2, next);</span><br><span class="line">		System.out.println(<span class="string">"index="</span> + index); <span class="comment">// 15了</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//写出我们的kmp搜索算法</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> str1 源字符串</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> str2 子串</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> next 部分匹配表, 是子串对应的部分匹配表</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 如果是-1就是没有匹配到，否则返回第一个匹配的位置</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmpSearch</span><span class="params">(String str1, String str2, <span class="keyword">int</span>[] next)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//遍历 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; str1.length(); i++) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//需要处理 str1.charAt(i) ！= str2.charAt(j), 去调整j的大小</span></span><br><span class="line">			<span class="comment">//KMP算法核心点, 可以验证...</span></span><br><span class="line">			<span class="keyword">while</span>( j &gt; <span class="number">0</span> &amp;&amp; str1.charAt(i) != str2.charAt(j)) &#123;</span><br><span class="line">				j = next[j-<span class="number">1</span>]; </span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(str1.charAt(i) == str2.charAt(j)) &#123;</span><br><span class="line">				j++;</span><br><span class="line">			&#125;			</span><br><span class="line">			<span class="keyword">if</span>(j == str2.length()) &#123;<span class="comment">//找到了 // j = 3 i </span></span><br><span class="line">				<span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取到一个字符串(子串) 的部分匹配值表</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span>[] kmpNext(String dest) &#123;</span><br><span class="line">		<span class="comment">//创建一个next 数组保存部分匹配值</span></span><br><span class="line">		<span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[dest.length()];</span><br><span class="line">		next[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//如果字符串是长度为1 部分匹配值就是0</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; dest.length(); i++) &#123;</span><br><span class="line">			<span class="comment">//当dest.charAt(i) != dest.charAt(j) ，我们需要从next[j-1]获取新的j</span></span><br><span class="line">			<span class="comment">//直到我们发现 有  dest.charAt(i) == dest.charAt(j)成立才退出</span></span><br><span class="line">			<span class="comment">//这时kmp算法的核心点</span></span><br><span class="line">			<span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; dest.charAt(i) != dest.charAt(j)) &#123;</span><br><span class="line">				j = next[j-<span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//当dest.charAt(i) == dest.charAt(j) 满足时，部分匹配值就是+1</span></span><br><span class="line">			<span class="keyword">if</span>(dest.charAt(i) == dest.charAt(j)) &#123;</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line">			next[i] = j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="46-贪心算法"><a href="#46-贪心算法" class="headerlink" title="46.贪心算法"></a>46.贪心算法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreedyAlgorithm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建广播电台,放入到Map</span></span><br><span class="line">		HashMap&lt;String,HashSet&lt;String&gt;&gt; broadcasts = <span class="keyword">new</span> HashMap&lt;String, HashSet&lt;String&gt;&gt;();</span><br><span class="line">		<span class="comment">//将各个电台放入到broadcasts</span></span><br><span class="line">		HashSet&lt;String&gt; hashSet1 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">		hashSet1.add(<span class="string">"北京"</span>);</span><br><span class="line">		hashSet1.add(<span class="string">"上海"</span>);</span><br><span class="line">		hashSet1.add(<span class="string">"天津"</span>);</span><br><span class="line">		</span><br><span class="line">		HashSet&lt;String&gt; hashSet2 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">		hashSet2.add(<span class="string">"广州"</span>);</span><br><span class="line">		hashSet2.add(<span class="string">"北京"</span>);</span><br><span class="line">		hashSet2.add(<span class="string">"深圳"</span>);</span><br><span class="line">		</span><br><span class="line">		HashSet&lt;String&gt; hashSet3 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">		hashSet3.add(<span class="string">"成都"</span>);</span><br><span class="line">		hashSet3.add(<span class="string">"上海"</span>);</span><br><span class="line">		hashSet3.add(<span class="string">"杭州"</span>);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		HashSet&lt;String&gt; hashSet4 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">		hashSet4.add(<span class="string">"上海"</span>);</span><br><span class="line">		hashSet4.add(<span class="string">"天津"</span>);</span><br><span class="line">		</span><br><span class="line">		HashSet&lt;String&gt; hashSet5 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">		hashSet5.add(<span class="string">"杭州"</span>);</span><br><span class="line">		hashSet5.add(<span class="string">"大连"</span>);</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//加入到map</span></span><br><span class="line">		broadcasts.put(<span class="string">"K1"</span>, hashSet1);</span><br><span class="line">		broadcasts.put(<span class="string">"K2"</span>, hashSet2);</span><br><span class="line">		broadcasts.put(<span class="string">"K3"</span>, hashSet3);</span><br><span class="line">		broadcasts.put(<span class="string">"K4"</span>, hashSet4);</span><br><span class="line">		broadcasts.put(<span class="string">"K5"</span>, hashSet5);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//allAreas 存放所有的地区</span></span><br><span class="line">		HashSet&lt;String&gt; allAreas = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">		allAreas.add(<span class="string">"北京"</span>);</span><br><span class="line">		allAreas.add(<span class="string">"上海"</span>);</span><br><span class="line">		allAreas.add(<span class="string">"天津"</span>);</span><br><span class="line">		allAreas.add(<span class="string">"广州"</span>);</span><br><span class="line">		allAreas.add(<span class="string">"深圳"</span>);</span><br><span class="line">		allAreas.add(<span class="string">"成都"</span>);</span><br><span class="line">		allAreas.add(<span class="string">"杭州"</span>);</span><br><span class="line">		allAreas.add(<span class="string">"大连"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//创建ArrayList, 存放选择的电台集合</span></span><br><span class="line">		ArrayList&lt;String&gt; selects = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//定义一个临时的集合， 在遍历的过程中，存放遍历过程中的电台覆盖的地区和当前还没有覆盖的地区的交集</span></span><br><span class="line">		HashSet&lt;String&gt; tempSet = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//定义给maxKey ， 保存在一次遍历过程中，能够覆盖最大未覆盖的地区对应的电台的key</span></span><br><span class="line">		<span class="comment">//如果maxKey 不为null , 则会加入到 selects</span></span><br><span class="line">		String maxKey = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">while</span>(allAreas.size() != <span class="number">0</span>) &#123; <span class="comment">// 如果allAreas 不为0, 则表示还没有覆盖到所有的地区</span></span><br><span class="line">			<span class="comment">//每进行一次while,需要</span></span><br><span class="line">			maxKey = <span class="keyword">null</span>;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//遍历 broadcasts, 取出对应key</span></span><br><span class="line">			<span class="keyword">for</span>(String key : broadcasts.keySet()) &#123;</span><br><span class="line">				<span class="comment">//每进行一次for</span></span><br><span class="line">				tempSet.clear();</span><br><span class="line">				<span class="comment">//当前这个key能够覆盖的地区</span></span><br><span class="line">				HashSet&lt;String&gt; areas = broadcasts.get(key);</span><br><span class="line">				tempSet.addAll(areas);</span><br><span class="line">				<span class="comment">//求出tempSet 和   allAreas 集合的交集, 交集会赋给 tempSet</span></span><br><span class="line">				tempSet.retainAll(allAreas);</span><br><span class="line">				<span class="comment">//如果当前这个集合包含的未覆盖地区的数量，比maxKey指向的集合地区还多</span></span><br><span class="line">				<span class="comment">//就需要重置maxKey</span></span><br><span class="line">				<span class="comment">// tempSet.size() &gt;broadcasts.get(maxKey).size()) 体现出贪心算法的特点,每次都选择最优的</span></span><br><span class="line">				<span class="keyword">if</span>(tempSet.size() &gt; <span class="number">0</span> &amp;&amp; </span><br><span class="line">						(maxKey == <span class="keyword">null</span> || tempSet.size() &gt;broadcasts.get(maxKey).size()))&#123;</span><br><span class="line">					maxKey = key;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//maxKey != null, 就应该将maxKey 加入selects</span></span><br><span class="line">			<span class="keyword">if</span>(maxKey != <span class="keyword">null</span>) &#123;</span><br><span class="line">				selects.add(maxKey);</span><br><span class="line">				<span class="comment">//将maxKey指向的广播电台覆盖的地区，从 allAreas 去掉</span></span><br><span class="line">				allAreas.removeAll(broadcasts.get(maxKey));</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"得到的选择结果是"</span> + selects);<span class="comment">//[K1,K2,K3,K5]</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="未完待续……"><a href="#未完待续……" class="headerlink" title="未完待续……"></a>未完待续……</h3></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">clay</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">http://yoursite.com/2020/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">clay's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java    </a><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">笔记    </a></div><div class="post_share"></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/03/10/test2/"><img class="prev_cover lazyload" data-src="https://pic.downk.cc/item/5e67934098271cb2b8c73db3.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>置顶文章测试</span></div></a></div><div class="next-post pull_right"><a href="/2020/03/09/java%E8%AF%AD%E6%B3%95-04/"><img class="next_cover lazyload" data-src="https://pic.downk.cc/item/5e6741ac98271cb2b89a451f.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>java语法-04</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/03/09/java语法-04/" title="java语法-04"><img class="relatedPosts_cover lazyload"data-src="https://pic.downk.cc/item/5e6741ac98271cb2b89a451f.jpg"><div class="relatedPosts_title">java语法-04</div></a></div><div class="relatedPosts_item"><a href="/2020/03/09/java语法-03/" title="java语法-03"><img class="relatedPosts_cover lazyload"data-src="https://pic.downk.cc/item/5e67934098271cb2b8c73db9.jpg"><div class="relatedPosts_title">java语法-03</div></a></div><div class="relatedPosts_item"><a href="/2020/03/09/java语法-02/" title="java语法-02"><img class="relatedPosts_cover lazyload"data-src="https://pic.downk.cc/item/5e67934098271cb2b8c73db3.jpg"><div class="relatedPosts_title">java语法-02</div></a></div><div class="relatedPosts_item"><a href="/2020/03/09/java语法-01/" title="java语法-01"><img class="relatedPosts_cover lazyload"data-src="https://pic.downk.cc/item/5e6741ac98271cb2b89a451f.jpg"><div class="relatedPosts_title">java语法-01</div></a></div></div><div class="clear_both"></div></div></div></div><footer id="footer" style="background-image: url(https://pic.downk.cc/item/5e67934098271cb2b8c73daf.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2020 By clay</div><div class="framework-info"><span>Powered By </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi , welcome to my <a href="http://g_clay.gitee.io/blog/" target="_blank" rel="noopener">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="/js/search/local-search.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.15/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>